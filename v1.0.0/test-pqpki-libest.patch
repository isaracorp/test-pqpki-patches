diff --git a/example/android/ESTClient/jni/est_wrapper.c b/example/android/ESTClient/jni/est_wrapper.c
index b19a3d5..941127b 100644
--- a/example/android/ESTClient/jni/est_wrapper.c
+++ b/example/android/ESTClient/jni/est_wrapper.c
@@ -272,7 +272,7 @@ Java_com_cisco_estclient_ESTActivity_enrollCert( JNIEnv* env,
      * Set the local authentication credentials.  We're not using
      * a certificate to identify ourselves to the server.  
      */
-    rv = est_client_set_auth(ectx, est_userid, est_password, NULL, NULL);
+    rv = est_client_set_auth(ectx, est_userid, est_password, NULL, NULL, NULL /*ISARA*/);
     if (rv != EST_ERR_NONE) {
         printf("\nUnable to configure client authentication.  Aborting!!!\n");
         printf("EST error code %d (%s)\n", rv, EST_ERR_NUM_TO_STR(rv));
@@ -281,7 +281,7 @@ Java_com_cisco_estclient_ESTActivity_enrollCert( JNIEnv* env,
 
     est_client_set_server(ectx, (const char*)server_name, port);
 
-    rv = est_client_enroll(ectx, (char *)common_name, &pkcs7_len, m_key);
+    rv = est_client_enroll(ectx, (char *)common_name, &pkcs7_len, m_key, NULL /*ISARA*/);
     if (rv != EST_ERR_NONE) {
 	__android_log_print(ANDROID_LOG_INFO, "EST:", "est_client_enroll rv=%d", rv);
 	ERR_print_errors_fp(stderr);
diff --git a/example/client-simple/estclient-simple.c b/example/client-simple/estclient-simple.c
index 0a18794..108e88a 100644
--- a/example/client-simple/estclient-simple.c
+++ b/example/client-simple/estclient-simple.c
@@ -53,6 +53,10 @@ static int est_port;
 static int srp = 0;
 static int token_auth_mode = 0;
 
+/* ISARA: BEGIN */
+static ENGINE *engine = NULL;
+/* ISARA: END */
+
 #define cert_file_name	"cert-b64.pkcs7"
 #define ca_file_name	"newcacerts.pkcs7"
 
@@ -161,7 +165,7 @@ static EST_CTX * setup_est_context (void)
      * simply hard-coding the userID and password, which will be
      * used for HTTP authentication.
      */
-    rv = est_client_set_auth(ectx, est_http_uid, est_http_pwd, NULL, NULL);
+    rv = est_client_set_auth(ectx, est_http_uid, est_http_pwd, NULL, NULL, NULL /*ISARA*/);
     if (rv != EST_ERR_NONE) {
         printf("\nUnable to configure client authentication.  Aborting!!!\n");
         printf("EST error code %d (%s)\n", rv, EST_ERR_NUM_TO_STR(rv));
@@ -220,6 +224,11 @@ int main (int argc, char **argv)
     };
     int option_index = 0;
 
+    /* ISARA: BEGIN */
+    char *alt_key_data = NULL;
+    EVP_PKEY *alt_key = NULL;
+    /* ISARA: END */
+
     est_http_uid[0] = 0x0;
     est_http_pwd[0] = 0x0;
 
@@ -276,6 +285,14 @@ int main (int argc, char **argv)
      */
     est_apps_startup();
         
+    /* ISARA: BEGIN */
+    engine = setup_engine("qs_sig");
+    if (engine == NULL) {
+        printf("\nUnable to load engine qs_sig\n");
+        exit(1);
+    }
+    /* ISARA: END */
+
     print_version();
     printf("\nUsing EST server %s:%d", est_server, est_port);
 
@@ -323,6 +340,30 @@ int main (int argc, char **argv)
     free(key_data);
     key_data = NULL;
 
+    /* ISARA: BEGIN */
+    /*
+     * Create an alternative public/private key pair that will be used for
+     * the enrollment.  We'll write this out to a local file called
+     * new_alt_key.pem.
+     */
+    alt_key_data = generate_private_HSS_key(NULL/* no password_cb */);
+
+    write_binary_file("./new_alt_key.pem", (unsigned char *)alt_key_data, strlen(alt_key_data));
+
+    /*
+     * Use the load_clear macro to load in an unencrypted key
+     */
+    alt_key = load_clear_private_key_PEM(alt_key_data);
+
+    if(!alt_key) {
+        printf("\nUnable to load newly created alt key from PEM file\n");
+        exit(1);
+    }
+    memset(alt_key_data, 0, strlen(alt_key_data));
+    free(alt_key_data);
+    alt_key_data = NULL;
+    /* ISARA: END */
+
     ectx = setup_est_context();
     if (!ectx) {
 	printf("\nUnable to create EST client context\n");
@@ -332,12 +373,13 @@ int main (int argc, char **argv)
     /*
      * Attempt to provision a new cert
      */
-    rv = est_client_provision_cert(ectx, "localhost", &p7_len, &ca_certs_len, key);
+    rv = est_client_provision_cert(ectx, "localhost", &p7_len, &ca_certs_len, key, alt_key /*ISARA*/);
     if (rv != EST_ERR_NONE) {
 	printf("\nProvisioning failed with error %s\n", EST_ERR_NUM_TO_STR(rv));
 	exit(1);
     } 
     EVP_PKEY_free(key);
+    EVP_PKEY_free(alt_key); // ISARA
 
     /*
      * Retrieve a copy of the cert
@@ -383,6 +425,11 @@ int main (int argc, char **argv)
     free(cacerts);
     est_destroy(ectx);
 
+    /* ISARA: BEGIN */
+    if (engine != NULL) {
+        ENGINE_free(engine);
+    }
+    /* ISARA: END */
     est_apps_shutdown();
 
     printf("\n");
diff --git a/example/client/estclient.c b/example/client/estclient.c
index ea3336a..18c07bb 100644
--- a/example/client/estclient.c
+++ b/example/client/estclient.c
@@ -108,6 +108,15 @@ X509 *client_cert_dup;
 
 EVP_PKEY *priv_key;
 
+/* ISARA: BEGIN */
+static ENGINE *engine = NULL;
+static char alt_priv_key_file[MAX_FILENAME_LEN];
+static char alt_client_key_file[MAX_FILENAME_LEN];
+static char *new_alt_pkey = NULL;
+EVP_PKEY *alt_client_priv_key = NULL;
+EVP_PKEY *alt_priv_key = NULL;
+/* ISARA: END */
+
 typedef struct {
     int	    thread_id;
 } THREAD_CTX;
@@ -184,6 +193,10 @@ static void show_usage_and_exit (void)
 	"  --proxy-auth   <BASIC|NTLM>  Proxy authentication method.\n"
 	"  --proxy-username <string>   username to pass to proxy server.\n"
 	"  --proxy-password <string>   password to pass to proxy server.\n"
+	/* ISARA: BEGIN */
+	"  --x-alt <keyfile>  Use existing alt private key in the given file for alt signing of the CSR.\n"
+	"  --k-alt <keyfile>  Use with -c option to specify alt private key for the identity cert.\n"
+	/* ISARA: END */
         "\n");
     exit(255);
 }
@@ -438,10 +451,10 @@ static int simple_enroll_attempt (EST_CTX *ectx, int  thread_id, int i)
         if (csr == NULL) {
             rv = EST_ERR_PEM_READ;
         } else  {
-            rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, NULL);
+            rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, NULL, NULL /*ISARA*/);
         }
     } else  {
-        rv = est_client_enroll(ectx, subj_cn, &pkcs7_len, priv_key);
+        rv = est_client_enroll(ectx, subj_cn, &pkcs7_len, priv_key, alt_priv_key /*ISARA*/);
     }
     if (csr) {
         X509_REQ_free(csr);
@@ -488,7 +501,7 @@ static int simple_enroll_attempt (EST_CTX *ectx, int  thread_id, int i)
 /*
  * Routine used to CSR for est_client_enroll_csr testcases
  */
-static int populate_x509_csr (X509_REQ *req, EVP_PKEY *pkey, char *cn)
+static int populate_x509_csr (X509_REQ *req, EVP_PKEY *pkey, EVP_PKEY *alt_pkey /*ISARA*/, char *cn)
 {
     X509_NAME *subj;
 
@@ -516,6 +529,16 @@ static int populate_x509_csr (X509_REQ *req, EVP_PKEY *pkey, char *cn)
         return (-1);
     }
 
+    /* ISARA: BEGIN */
+    /* Add the alt public key to the CSR */
+    if (alt_pkey != NULL) {
+        if (est_client_csr_add_alt_pubkey(req, alt_pkey) != EST_ERR_NONE) {
+            printf("\nFailed to add alt public key");
+            return (-1);
+        }
+    }
+    /* ISARA: END */
+
     return (0);
 }
 
@@ -569,7 +592,7 @@ static int regular_enroll_attempt (EST_CTX *ectx, int  thread_id, int i)
         printf("\nFailed to get X509_REQ");
         return (EST_ERR_NO_CSR);
     }
-    rv = populate_x509_csr(csr, priv_key, "EST-client");
+    rv = populate_x509_csr(csr, priv_key, alt_priv_key /*ISARA*/, "EST-client");
 
     if (rv) {
         printf("\nFailed to populate X509_REQ");
@@ -624,7 +647,7 @@ static int regular_enroll_attempt (EST_CTX *ectx, int  thread_id, int i)
 
     X509_REQ_print_fp(stderr, csr);
 
-    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, priv_key);
+    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, priv_key, alt_priv_key /*ISARA*/);
 
     if (verbose) {
         printf("\nenrollment rv = %d (%s) with pkcs7 length = %d\n",
@@ -751,13 +774,24 @@ static void worker_thread (void *ptr)
 	    exit(1);
 	}
 
-        rv = est_client_set_auth(ectx, est_http_uid, est_http_pwd, client_cert, client_priv_key);
+        rv = est_client_set_auth(ectx, est_http_uid, est_http_pwd, client_cert, client_priv_key, alt_client_priv_key /*ISARA*/);
         if (rv != EST_ERR_NONE) {
 	    printf("\nUnable to configure client authentication.  Aborting!!!\n");
 	    printf("EST error code %d (%s)\n", rv, EST_ERR_NUM_TO_STR(rv));
 	    exit(1);
 	}
 
+    /* ISARA: BEGIN */
+    /* Enable basic auth. For this demo we know that the server accepts basic
+     * authentication so enabling it now removes an extra round-trip between
+     * the client and server.  This is also important because each round trip
+     * burns a one-time signature in the private HSS keys. */
+    rv = est_client_enable_basic_auth_hint(ectx);
+    if (rv != EST_ERR_NONE) {
+        printf("\nUnable to enable basic auth.  Aborting!!!\n");
+        exit(1);
+    }
+    /* ISARA: END */
 
 	if (srp) {
 	    rv = est_client_enable_srp(ectx, 1024, est_srp_uid, est_srp_pwd);
@@ -890,7 +924,7 @@ static void worker_thread (void *ptr)
 	if (reenroll) {
 	    operation = "Re-enrollment";
 
-	    rv = est_client_reenroll(ectx, client_cert_dup, &pkcs7_len, client_priv_key);
+	    rv = est_client_reenroll(ectx, client_cert_dup, &pkcs7_len, client_priv_key, alt_client_priv_key /*ISARA*/);
 	    if (verbose) printf("\nreenroll rv = %d (%s) with pkcs7 length = %d\n",
                                 rv, EST_ERR_NUM_TO_STR(rv), pkcs7_len);
 	    if (rv == EST_ERR_NONE) {
@@ -996,6 +1030,10 @@ int main (int argc, char **argv)
         {"proxy-auth", 1, 0, 0 },
         {"proxy-username", 1, 0, 0 },
         {"proxy-password", 1, 0, 0 },
+        /* ISARA: BEGIN */
+        {"x-alt", 1, 0, 0 },
+        {"k-alt", 1, 0, 0 },
+        /* ISARA: END */
         {NULL, 0, NULL, 0}
     };
     int option_index = 0;
@@ -1016,6 +1054,11 @@ int main (int argc, char **argv)
     memset(client_cert_file, 0, 1);
     memset(out_dir, 0, 1);
 
+    /* ISARA: BEGIN */
+    memset(alt_priv_key_file, 0, 1);
+    memset(alt_client_key_file, 0, 1);
+    /* ISARA: END */
+
     while ((c = getopt_long(argc, argv, "?zfvagerx:y:k:s:p:o:c:t:w:i:u:h:", long_options, &option_index)) != -1) {
         switch (c) {
             case 0:
@@ -1101,6 +1144,14 @@ int main (int argc, char **argv)
         if (!strncmp(long_options[option_index].name, "pem-output", strlen("pem-output"))) {
             pem_out = 1;
         }
+                /* ISARA: BEGIN */
+                if (!strncmp(long_options[option_index].name,"x-alt", strlen("x-alt"))) {
+                    strncpy(alt_priv_key_file, optarg, MAX_FILENAME_LEN);
+                }
+                if (!strncmp(long_options[option_index].name,"k-alt", strlen("k-alt"))) {
+                    strncpy(alt_client_key_file, optarg, MAX_FILENAME_LEN);
+                }
+                /* ISARA: END */
                 break;
             case 'v':
                 verbose = 1;
@@ -1211,6 +1262,12 @@ int main (int argc, char **argv)
         printf("\nError: The -x option (private key for CSR) does not make sense with a pre-defined CSR\n");
         exit(1);
     }
+    /* ISARA: BEGIN */
+    if (csr_file[0] && alt_priv_key_file[0]) {
+        printf("\nError: The --x-alt option (private alternative key for CSR) does not make sense with a pre-defined CSR\n");
+        exit(1);
+    }
+    /* ISARA: END */
     if (csr_file[0] && force_pop) {
         printf("\nError: The -z option (PoP) does not make sense with a pre-defined CSR\n");
         exit(1);
@@ -1229,12 +1286,22 @@ int main (int argc, char **argv)
         if (priv_key_file   [0]) {
             printf("\nUsing identity private key file %s", priv_key_file);
         }
+        /* ISARA: BEGIN */
+        if (alt_priv_key_file [0]) {
+            printf("\nUsing identity alternative private key file %s", alt_priv_key_file);
+        }
+        /* ISARA: END */
         if (client_cert_file[0]) {
             printf("\nUsing identity client cert file %s", client_cert_file);
         }
         if (client_key_file [0]) {
             printf("\nUsing identity private key file %s", client_key_file);
         }
+        /* ISARA: BEGIN */
+        if (alt_client_key_file [0]) {
+            printf("\nUsing identity alternative private key file %s", alt_client_key_file);
+        }
+        /* ISARA: END */
     }
 
     if (enroll && reenroll) {
@@ -1271,6 +1338,14 @@ int main (int argc, char **argv)
 
     est_apps_startup();
 
+    /* ISARA: BEGIN */
+    engine = setup_engine("qs_sig");
+    if (engine == NULL) {
+        printf("\nUnable to load engine qs_sig\n");
+        exit(1);
+    }
+    /* ISARA: END */
+
     /*
      * Read in the current client certificate
      */
@@ -1315,6 +1390,26 @@ int main (int argc, char **argv)
         }
     }
 
+    /* ISARA: BEGIN */
+    /*
+     * Read in the client's alt private key. We don't support encrypted private
+     * keys because the key might have state which needs to be saved back to
+     * the file.
+     */
+    if (alt_client_key_file[0]) {
+        alt_client_priv_key = read_private_key(alt_client_key_file, NULL);
+        if (alt_client_priv_key == NULL) {
+            printf("\nError while reading PEM encoded alternative private key file %s\n", alt_client_key_file);
+            ERR_print_errors_fp(stderr);
+            exit(1);
+        }
+        if (set_pkey_filename(alt_client_priv_key, alt_client_key_file) != EST_ERR_NONE) {
+            ERR_print_errors_fp(stderr);
+            exit(1);
+        }
+    }
+    /* ISARA: END */
+
 #if 0
     CRYPTO_malloc_debug_init();
     CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
@@ -1364,6 +1459,52 @@ int main (int argc, char **argv)
         }
     }
 
+    /* ISARA: BEGIN */
+    if (!alt_priv_key_file[0] && enroll && !csr_file[0]) {
+        printf("\nAn alternative private key is required for enrolling.  Creating a new HSS key pair since you didn't provide a key using the --x-alt option.");
+        /*
+         * Create a private alt key that will be used for all
+         * the enrollments.  Normally, there would be one
+         * key per cert.  But we do this to improve
+         * performance when simulating multiple clients
+         */
+        new_alt_pkey = generate_private_HSS_key(priv_key_cb);
+        if(new_alt_pkey == NULL) {
+            exit(1);
+        }
+        snprintf(file_name, MAX_FILENAME_LEN, "%s/alt-key-x-x.pem", out_dir);
+        write_binary_file(file_name, (unsigned char *)new_alt_pkey, strlen((const char *)new_alt_pkey));
+        memset(new_alt_pkey, 0, strlen(new_alt_pkey));
+        free(new_alt_pkey);
+        new_alt_pkey = NULL;
+
+        /*
+         * prepare to read it back in to an EVP_PKEY struct
+         */
+        strncpy(alt_priv_key_file, file_name, MAX_FILENAME_LEN);
+    }
+
+    /* Read in the alt private key file */
+    if (enroll && !csr_file[0]) {
+        if (alt_client_key_file[0] && strcmp(alt_client_key_file, alt_priv_key_file) == 0) {
+            /* The alt client auth key and the alt private key to register are
+             * the same key.  Use the same PKEY object so that the file is
+             * updated correctly on signing.
+             * XXX: the check above will fail if two different file paths refer
+             * to the same file.  */
+            alt_priv_key = alt_client_priv_key;
+        } else {
+            alt_priv_key = read_private_key(alt_priv_key_file, priv_key_cb);
+            if (alt_priv_key == NULL) {
+                exit(1);
+            }
+            if (set_pkey_filename(alt_priv_key, alt_priv_key_file) != EST_ERR_NONE) {
+                exit(1);
+            }
+        }
+    }
+    /* ISARA: END */
+
 #ifndef DISABLE_PTHREADS
     /*
      * Install thread locking mechanism for OpenSSL
@@ -1429,6 +1570,11 @@ int main (int argc, char **argv)
         free(c_key);
     }
 
+    /* ISARA: BEGIN */
+    if (engine != NULL) {
+        ENGINE_free(engine);
+    }
+    /* ISARA: END */
     est_apps_shutdown();
 #if 0
     BIO *bio_err;
diff --git a/example/client/isara_req.cfg b/example/client/isara_req.cfg
new file mode 100644
index 0000000..11e276c
--- /dev/null
+++ b/example/client/isara_req.cfg
@@ -0,0 +1,29 @@
+# @file isara_req.cfg Configuration file for creating a certificate.
+#
+# @copyright Copyright 2017 ISARA Corporation
+#
+# @license Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+[ req ]
+default_bits           = 2048
+distinguished_name     = req_distinguished_name
+prompt                 = no
+
+[ req_distinguished_name ]
+C                      = CA
+ST                     = Ontario
+L                      = Waterloo
+O                      = ISARA Corporation
+OU                     = Developer Team
+CN                     = 127.0.0.1
+emailAddress           = quantumsafe@isara.com
diff --git a/example/server/ESTcommon.sh b/example/server/ESTcommon.sh
index e58d1c9..4fdb64f 100644
--- a/example/server/ESTcommon.sh
+++ b/example/server/ESTcommon.sh
@@ -28,6 +28,9 @@ EST_OPENSSL_EXTCADATABASE=$EST_OPENSSL_EXTCADIR/index.txt
 EST_OPENSSL_EXTCASERIAL=$EST_OPENSSL_EXTCADIR/serial
 EST_OPENSSL_EXTCAPRIVKEY=$EST_OPENSSL_EXTCAPRIVDIR/cakey.pem
 EST_OPENSSL_EXTCAPRIVKEYPARAM=$EST_OPENSSL_EXTCAPRIVDIR/cakeyparam.pem
+# ISARA: BEGIN
+EST_OPENSSL_EXTCAPRIVKEY2=$EST_OPENSSL_EXTCAPRIVDIR/cakey2.pem
+# ISARA: END
 EST_OPENSSL_EXTCASUBJ="/CN=estEXTERNALCA"
 
 EST_OPENSSLCMD_EXTCAECPARAMSFILE=$EST_OPENSSL_EXTCADIR/prime256v1.pem
@@ -44,6 +47,9 @@ EST_OPENSSL_CADATABASE=$EST_OPENSSL_CADIR/index.txt
 EST_OPENSSL_CASERIAL=$EST_OPENSSL_CADIR/serial
 EST_OPENSSL_CAPRIVKEY=$EST_OPENSSL_CAPRIVDIR/cakey.pem
 EST_OPENSSL_CAPRIVKEYPARAM=$EST_OPENSSL_CAPRIVDIR/cakeyparam.pem
+# ISARA: BEGIN
+EST_OPENSSL_CAPRIVKEY2=$EST_OPENSSL_CAPRIVDIR/cakey2.pem
+# ISARA: END
 EST_OPENSSL_CASUBJ="/CN=estExampleCA"
 
 EST_OPENSSLCMD_CAECPARAMSFILE=$EST_OPENSSL_CADIR/prime256v1.pem
@@ -72,6 +78,9 @@ EST_SERVER_SUBJ="/CN=127.0.0.1"
 EST_SERVER_CERTREQ=$EST_OPENSSL_CADIR/estserver.req
 EST_SERVER_CERT=$EST_OPENSSL_CADIR/estserver.crt
 EST_SERVER_PRIVKEY=$EST_OPENSSL_CAPRIVDIR/estserver.pem
+# ISARA: BEGIN
+EST_SERVER_PRIVKEY2=$EST_OPENSSL_CAPRIVDIR/estserver2.pem
+# ISARA: END
 EST_SERVER_CERTANDKEY=$EST_OPENSSL_CAPRIVDIR/estservercertandkey.pem
 
 EST_SERVER_CCAUTHZDB=ccAuthz.db
diff --git a/example/server/createCA.sh b/example/server/createCA.sh
index c2a8097..47a5e31 100755
--- a/example/server/createCA.sh
+++ b/example/server/createCA.sh
@@ -39,6 +39,9 @@ function createCA ()
     CREATECA_CAPRIVKEY=$8
     CREATECA_NEWKEY_PARAM=$9
     CREATECA_ECPARAMSFILE=${10}
+    # ISARA: BEGIN
+    CREATECA_CAPRIVKEY2=${11}
+    # ISARA: END
 
     echo "#################################################################"
     echo "####(Re)creating the directory structure and initial files" 
@@ -56,7 +59,18 @@ function createCA ()
 
     eval $OPENSSLCMD req -new -x509 -sha256 -extensions v3_ca $CREATECA_NEWKEY_PARAM -keyout $CREATECA_CAPRIVKEY -out $CREATECA_CACERT -days 365 -nodes -subj "$CREATECA_CASUBJ" -config $EST_OPENSSL_CACNF
     iferrorlogandexit "Unable to create \"$CREATECA_CASUBJ\" CA cert" 1
-    $OPENSSLCMD x509 -sha256 -in $CREATECA_CACERT
+    # ISARA: BEGIN
+    # generate alternative key to use in multiple public-key algorithm certificate
+    $OPENSSLCMD genpkey -engine qs_sig -algorithm hss -pkeyopt winternitz_value:8 -pkeyopt tree_height:10 -out $CREATECA_CAPRIVKEY2
+    iferrorlogandexit "Unable to create \"$CREATECA_CASUBJ\" second key" 1
+    mv $CREATECA_CACERT "${CREATECA_CACERT}.bak"
+    # Convert certificate to multiple public-key algorithm certificate
+    $OPENSSLCMD x509QSDirectExtend -engine qs_sig -x509in "${CREATECA_CACERT}.bak" -x509out $CREATECA_CACERT -privin $CREATECA_CAPRIVKEY -self_sign -privqs $CREATECA_CAPRIVKEY2
+    iferrorlogandexit "Unable to create \"$CREATECA_CASUBJ\" CA cert" 1
+    rm "${CREATECA_CACERT}.bak"
+    $OPENSSLCMD x509 -engine qs_sig -sha256 -in $CREATECA_CACERT -noout -text
+    #$OPENSSLCMD x509 -sha256 -in $CREATECA_CACERT
+    # ISARA: END
 }
 
 # Create a 3rd party (existing) CA certificate
@@ -73,7 +87,8 @@ createCA $EST_OPENSSL_EXTCASUBJ \
     $EST_OPENSSL_EXTCANEWCERTSDIR \
     $EST_OPENSSL_EXTCAPRIVKEY \
     "$EST_OPENSSLCMD_EXTCANEWKEY_PARAM" \
-    "$EST_OPENSSLCMD_EXTCAECPARAMSFILE" 
+    "$EST_OPENSSLCMD_EXTCAECPARAMSFILE" \
+    $EST_OPENSSL_EXTCAPRIVKEY2 # ISARA
 
 # Create our CA certificate
 echo "#################################################################"
@@ -88,7 +103,8 @@ createCA $EST_OPENSSL_CASUBJ \
     $EST_OPENSSL_CANEWCERTSDIR \
     $EST_OPENSSL_CAPRIVKEY \
     "$EST_OPENSSLCMD_CANEWKEY_PARAM" \
-    "$EST_OPENSSLCMD_CAECPARAMSFILE"
+    "$EST_OPENSSLCMD_CAECPARAMSFILE" \
+    $EST_OPENSSL_CAPRIVKEY2 # ISARA
 
 # Create a certificate for our est server
 # TODO: add extension for est server
@@ -98,9 +114,27 @@ echo "#################################################################"
 # re-using the same NEWKEY_PARAM as is used for our CA
 eval $OPENSSLCMD req -new -sha256 -nodes -out $EST_SERVER_CERTREQ $EST_OPENSSLCMD_CANEWKEY_PARAM -keyout $EST_SERVER_PRIVKEY -subj $EST_SERVER_SUBJ -config $EST_OPENSSL_CACNF
 iferrorlogandexit "Unable to create est server CSR" 1
+# ISARA: BEGIN
+# generate alternative key to use as second key in multiple public-key algorithm certificate
+$OPENSSLCMD genpkey -engine qs_sig -algorithm hss -pkeyopt winternitz_value:8 -pkeyopt tree_height:10 -pkeyopt aux_length:40000 -out $EST_SERVER_PRIVKEY2
+iferrorlogandexit "Unable to create est server second key" 1
+mv $EST_SERVER_CERTREQ "${EST_SERVER_CERTREQ}.bak"
+# Convert certificate request to multiple public-key algorithm certificate request
+$OPENSSLCMD reqQSExtend -engine qs_sig -reqin "${EST_SERVER_CERTREQ}.bak" -reqout $EST_SERVER_CERTREQ -privin $EST_SERVER_PRIVKEY -privqs $EST_SERVER_PRIVKEY2
+iferrorlogandexit "Unable to convert to est server multiple public-key algorithm CSR" 1
+rm "${EST_SERVER_CERTREQ}.bak"
+# ISARA: END
 $OPENSSLCMD ca -md sha256 -out $EST_SERVER_CERT -batch -config $EST_OPENSSL_CACNF -extfile ./ext.cnf -infiles $EST_SERVER_CERTREQ 
 iferrorlogandexit "Unable to create est server certificate" 1
-$OPENSSLCMD x509 -sha256 -in $EST_SERVER_CERT -text
+# ISARA: BEGIN
+mv $EST_SERVER_CERT "${EST_SERVER_CERT}.bak"
+# Convert certificate to multiple public-key algorithm certificate
+$OPENSSLCMD x509QSExtend -engine qs_sig  -x509in "${EST_SERVER_CERT}.bak" -x509out $EST_SERVER_CERT -privin $EST_OPENSSL_CAPRIVKEY -reqin $EST_SERVER_CERTREQ -privqs $EST_OPENSSL_CAPRIVKEY2
+iferrorlogandexit "Unable to convert to est server multiple public-key algorithm cert" 1
+rm "${EST_SERVER_CERT}.bak"
+$OPENSSLCMD x509 -engine qs_sig -sha256 -in $EST_SERVER_CERT -text -noout
+#$OPENSSLCMD x509 -sha256 -in $EST_SERVER_CERT -text
+# ISARA: END
 # the mongoose https server wants to recieve the server certificate in
 # a combined file:
 if [ -e $EST_SERVER_CERTANDKEY ] ; then 
diff --git a/example/server/estExampleCA.cnf b/example/server/estExampleCA.cnf
index 2fb2306..7a1eade 100644
--- a/example/server/estExampleCA.cnf
+++ b/example/server/estExampleCA.cnf
@@ -37,6 +37,11 @@ x509_extensions = client_cert          # The extensions to add to certs issued
 # checking. This significantly reduces the security of this CA!!
 unique_subject=no
 
+# ISARA: BEGIN
+alt_private_key = $dir/private/cakey2.pem   # CA private alt key
+alt_default_md  = sha512                    # md to use for alt signature
+# ISARA: END
+
 # This policy applies to clients *and* it apples to the CA cert itself
 [ policy_any ]
 commonName              = supplied
diff --git a/example/server/estserver.c b/example/server/estserver.c
index a5dcf5c..bdca9a5 100644
--- a/example/server/estserver.c
+++ b/example/server/estserver.c
@@ -95,6 +95,11 @@ SRP_VBASE *srp_db = NULL;
 
 static char valid_token_value[MAX_AUTH_TOKEN_LEN + 1];
 
+/* ISARA: BEGIN */
+static ENGINE *engine = NULL;
+char alt_keyfile[EST_MAX_FILE_LEN];
+/* ISARA: END */
+
 /*
  * This is the single EST context we need for operating
  * the EST server.  Only a single context is required.
@@ -173,6 +178,9 @@ static void show_usage_and_exit (void)
             "  -v           Verbose operation\n"
             "  -c <file>    PEM file to use for server cert\n"
             "  -k <file>    PEM file to use for server key\n"
+            /* ISARA: BEGIN */
+            "  -q <file>    PEM file to use for alt server key. This file will be rewritten so it must only contain the alt server key\n"
+            /* ISARA: END */
             "  -r <value>   HTTP realm to present to clients. Max is 32 characters.\n"
             "  -l           Enable CRL checks\n"
             "  -t           Enable check for binding client PoP to the TLS UID\n"
@@ -584,7 +592,13 @@ pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
 #else
 static CRITICAL_SECTION enrollment_critical_section;
 #endif
+/* ISARA: BEGIN */
+/* Multiple public-key algorithm certificates are large, so increase maximum size */
+#define MAX_CERT_LEN 262144
+/*
 #define MAX_CERT_LEN 8192
+*/
+/* ISARA: END */
 /*
  * Callback function used by EST stack to process a PKCS10
  * enrollment request with the CA.  The parameters are:
@@ -935,6 +949,11 @@ void cleanup (void)
     BIO_free(bio_err);
     free(cacerts_raw);
     free(trustcerts);
+    /* ISARA: BEGIN */
+    if (engine != NULL) {
+        ENGINE_free(engine);
+    }
+    /* ISARA: END */
     est_apps_shutdown();
 #ifndef WIN32
     pthread_mutex_destroy(&m);
@@ -957,6 +976,7 @@ int main (int argc, char **argv)
 
     X509 *x;
     EVP_PKEY * priv_key;
+    EVP_PKEY * alt_priv_key = NULL; /* ISARA */
     BIO *certin;
     DH *dh;
     EST_ERROR rv;
@@ -987,7 +1007,7 @@ int main (int argc, char **argv)
         show_usage_and_exit();
     }
 
-    while ((c = getopt_long(argc, argv, "?fhbwnovr:c:k:m:p:d:lt6", long_options,
+    while ((c = getopt_long(argc, argv, "?fhbwnovr:c:k:q:m:p:d:lt6", long_options,
         &option_index)) != -1) {
         switch (c) {
         case 0:
@@ -1066,6 +1086,11 @@ int main (int argc, char **argv)
         case 'k':
             strncpy(keyfile, optarg, EST_MAX_FILE_LEN);
             break;
+        /* ISARA: BEGIN */
+        case 'q':
+            strncpy(alt_keyfile, optarg, EST_MAX_FILE_LEN);
+            break;
+        /* ISARA: END */
         case 'r':
             if (strnlen(optarg, MAX_REALM_LEN+1) > MAX_REALM_LEN) {
                 printf("\nRealm value is too large.  Max is 32 characters\n");
@@ -1135,6 +1160,14 @@ int main (int argc, char **argv)
 
     est_apps_startup();
 
+    /* ISARA: BEGIN */
+    engine = setup_engine("qs_sig");
+    if (engine == NULL) {
+        printf("\nUnable to load engine qs_sig\n");
+        exit(1);
+    }
+    /* ISARA: END */
+
     /*
      * Read in the local server certificate
      */
@@ -1167,6 +1200,26 @@ int main (int argc, char **argv)
         exit(1);
     }
 
+    /* ISARA: BEGIN */
+    if (alt_keyfile[0] != '\0') {
+        /* Read the alt private key, we don't support encrypted private keys because
+         * the key might have state which needs to be saved back to the file. */
+        alt_priv_key = read_private_key(alt_keyfile, NULL);
+        if (alt_priv_key == NULL) {
+            printf("\nError while reading PEM encoded server alt private key file %s\n",
+                alt_keyfile);
+            ERR_print_errors_fp(stderr);
+            exit(1);
+        }
+        if (set_pkey_filename(alt_priv_key, alt_keyfile) != EST_ERR_NONE) {
+            printf("\nError while setting alt private key filename %s\n",
+                alt_keyfile);
+            ERR_print_errors_fp(stderr);
+            exit(1);
+        }
+    }
+    /* ISARA: END */
+
     bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
     if (!bio_err) {
         printf("\nBIO not working\n");
@@ -1180,7 +1233,7 @@ int main (int argc, char **argv)
         est_init_logger(EST_LOG_LVL_ERR, NULL);
     }
     ectx = est_server_init(trustcerts, trustcerts_len, cacerts_raw, cacerts_len,
-        EST_CERT_FORMAT_PEM, realm, x, priv_key);
+        EST_CERT_FORMAT_PEM, realm, x, priv_key, alt_priv_key /*ISARA*/);
     if (!ectx) {
         printf("\nUnable to initialize EST context.  Aborting!!!\n");
         exit(1);
@@ -1225,6 +1278,14 @@ int main (int argc, char **argv)
         }
     }
 
+    /* ISARA: BEGIN */
+    if (ossl_preload_alt_key()) {
+        printf(
+            "\nUnable to preload OSSL Alt key.  Aborting!!!\n");
+        exit(1);
+    }
+    /* ISARA: END */
+
     if (est_set_ca_enroll_cb(ectx, &process_pkcs10_enrollment)) {
         printf(
             "\nUnable to set EST pkcs10 enrollment callback.  Aborting!!!\n");
@@ -1353,6 +1414,11 @@ int main (int argc, char **argv)
 
     cleanup();
     EVP_PKEY_free(priv_key);
+    /* ISARA: BEGIN */
+    ossl_free_preloaded_alt_key();
+    EVP_PKEY_free(alt_priv_key);
+    release_engine(engine);
+    /* ISARA: END */
     X509_free(x);
     return 0;
 }
diff --git a/example/server/ossl_srv.c b/example/server/ossl_srv.c
index 0b9abd0..1184116 100644
--- a/example/server/ossl_srv.c
+++ b/example/server/ossl_srv.c
@@ -90,6 +90,10 @@
 #include <openssl/bio.h>
 #include "apps.h"  //taken from openssl/apps/apps.h
 
+/* ISARA: BEGIN */
+#include "est.h"
+/* ISARA: END */
+
 extern BIO *bio_err;
 BIO *cacerts = NULL;
 static int msie_hack = 0;
@@ -140,6 +144,11 @@ static BIO * ossl_get_certs_pkcs7(BIO *in);
 #define ENV_DATABASE        "database"
 #define BSIZE 256
 
+/* ISARA: BEGIN */
+#define ENV_ALT_PRIVATE_KEY  "alt_private_key"
+#define ENV_ALT_DEFAULT_MD   "alt_default_md"
+/* ISARA: END */
+
 int parse_yesno(const char *str, int def);
 int rand_serial(BIGNUM *b, ASN1_INTEGER *ai);
 
@@ -1398,7 +1407,7 @@ STACK_OF(OPENSSL_STRING) *sigopts) {
     return rv > 0 ? 1 : 0;
 }
 
-static int do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509, const EVP_MD *dgst,
+static int do_body(X509 **xret, EVP_PKEY *pkey, EVP_PKEY *alt_pkey /*ISARA*/, X509 *x509, const EVP_MD *dgst, const EVP_MD *alt_dgst /*ISARA*/,
 STACK_OF(OPENSSL_STRING) *sigopts, STACK_OF(CONF_VALUE) *policy, CA_DB *db,
         BIGNUM *serial, char *subj, unsigned long chtype, int multirdn,
         int email_dn, char *startdate, char *enddate, long days, int batch,
@@ -1852,6 +1861,15 @@ STACK_OF(OPENSSL_STRING) *sigopts, STACK_OF(CONF_VALUE) *policy, CA_DB *db,
         EVP_PKEY_copy_parameters(pktmp, pkey);
     EVP_PKEY_free(pktmp);
 
+    /* ISARA: BEGIN */
+    if (alt_pkey != NULL) {
+        if (EST_ERR_NONE != est_server_cert_add_alt_extensions(ret, req, alt_pkey, alt_dgst)) {
+            BIO_printf(bio_err, "Alt signing error\n");
+            goto err;
+        }
+    }
+    /* ISARA: END */
+
     if (!do_X509_sign(bio_err, ret, pkey, dgst, sigopts))
         goto err;
 
@@ -1916,8 +1934,8 @@ STACK_OF(OPENSSL_STRING) *sigopts, STACK_OF(CONF_VALUE) *policy, CA_DB *db,
     return (ok);
 }
 
-static int certify(X509 **xret, char *inptr, EVP_PKEY *pkey, X509 *x509,
-        const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
+static int certify(X509 **xret, char *inptr, EVP_PKEY *pkey, EVP_PKEY *alt_pkey /*ISARA*/, X509 *x509,
+        const EVP_MD *dgst, const EVP_MD *alt_dgst /*ISARA*/, STACK_OF(OPENSSL_STRING) *sigopts,
         STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial, char *subj,
         unsigned long chtype, int multirdn, int email_dn, char *startdate,
         char *enddate, long days, int batch, char *ext_sect, CONF *lconf,
@@ -1945,6 +1963,8 @@ static int certify(X509 **xret, char *inptr, EVP_PKEY *pkey, X509 *x509,
 
     BIO_printf(bio_err, "Check that the request matches the signature\n");
 
+    /* ISARA: certificates aren't self-signed when enrolled over EST so we
+     * don't need to check the alt private key against the CSR */
     if (selfsign && !X509_REQ_check_private_key(req, pkey)) {
         BIO_printf(bio_err,
                 "Certificate request and CA private key do not match\n");
@@ -1955,6 +1975,9 @@ static int certify(X509 **xret, char *inptr, EVP_PKEY *pkey, X509 *x509,
         BIO_printf(bio_err, "error unpacking public key\n");
         goto err;
     }
+    /* ISARA: The EST server already verifies the CSR (including dual-key
+     * extensions so we don't verify it again here (even though the classical
+     * CSR signature is re-verified here) */
     i = X509_REQ_verify(req, pktmp);
     EVP_PKEY_free(pktmp);
     if (i < 0) {
@@ -1970,7 +1993,7 @@ static int certify(X509 **xret, char *inptr, EVP_PKEY *pkey, X509 *x509,
     } else
         BIO_printf(bio_err, "Signature ok\n");
 
-    ok = do_body(xret, pkey, x509, dgst, sigopts, policy, db, serial, subj,
+    ok = do_body(xret, pkey, alt_pkey /*ISARA*/, x509, dgst, alt_dgst /*ISARA*/, sigopts, policy, db, serial, subj,
             chtype, multirdn, email_dn, startdate, enddate, days, batch,
             verbose, req, ext_sect, lconf, certopt, nameopt, default_op,
             ext_copy, selfsign);
@@ -2062,6 +2085,128 @@ static int check_time_format(const char *str) {
  *
  ****************************************************************************/
 
+/* ISARA: BEGIN */
+static EVP_PKEY *preloaded_alt_pkey = NULL;
+
+void ossl_free_preloaded_alt_key() {
+    EVP_PKEY_free(preloaded_alt_pkey);
+    preloaded_alt_pkey = NULL;
+}
+
+/*
+ * This function preloads the alternate private key for use by the CA server.
+ * It must be loaded once rather than reloaded on every certification because
+ * large HSS keys can take a long time to load and doing so on every
+ * certification could easily time out the connection.
+ */
+int ossl_preload_alt_key() {
+    char *configfile = NULL;
+    char passargin[20] = "pass:hello";
+    long errorline = -1;
+    int alt_keyform = FORMAT_PEM;
+    char *alt_keyfile = NULL;
+    char *alt_key = NULL;
+    int free_alt_key = 0;
+    EVP_PKEY_CTX *tmpctx = NULL;
+    int ret = -1;
+
+    if (preloaded_alt_pkey) {
+        return 0;
+    }
+
+    conf = NULL;
+    section = NULL;
+
+    if (bio_err == NULL)
+        if ((bio_err = BIO_new(BIO_s_file())) != NULL)
+            BIO_set_fp(bio_err, stderr, BIO_NOCLOSE|BIO_FP_TEXT);
+
+    if (configfile == NULL)
+        configfile = getenv("EST_OPENSSL_CACONFIG");
+    if (configfile == NULL) {
+        BIO_printf(bio_err,
+                "\nConfig file not set, set EST_OPENSSL_CACONFIG to resolve");
+        goto err;
+    }
+
+    BIO_printf(bio_err, "Using configuration from %s\n", configfile);
+    conf = NCONF_new(NULL);
+    if (NCONF_load(conf, configfile, &errorline) <= 0) {
+        if (errorline <= 0)
+            BIO_printf(bio_err, "error loading the config file '%s'\n",
+                    configfile);
+        else
+            BIO_printf(bio_err, "error on line %ld of config file '%s'\n",
+                    errorline, configfile);
+        goto err;
+    }
+
+    if (!load_config(bio_err, conf))
+        goto err;
+
+    /* Lets get the config section we are using */
+    if (section == NULL) {
+        section = NCONF_get_string(conf, BASE_SECTION, ENV_DEFAULT_CA);
+        if (section == NULL) {
+            lookup_fail(BASE_SECTION, ENV_DEFAULT_CA);
+            goto err;
+        }
+    }
+
+    if (alt_keyfile == NULL) {
+        alt_keyfile = NCONF_get_string(conf, section, ENV_ALT_PRIVATE_KEY);
+    }
+    if (alt_keyfile != NULL) {
+        if (!alt_key) {
+            free_alt_key = 1;
+            if (!app_passwd(bio_err, passargin, NULL, &alt_key, NULL)) {
+                BIO_printf(bio_err, "Error getting password\n");
+                goto err;
+            }
+        }
+        preloaded_alt_pkey = load_key(bio_err, alt_keyfile, alt_keyform, 0, alt_key, NULL, "CA alt private key");
+        if (alt_key) {
+            OPENSSL_cleanse(alt_key, strlen(alt_key));
+        }
+        if (preloaded_alt_pkey == NULL) {
+            /* load_key() has already printed an appropriate message */
+            goto err;
+        }
+
+        if (preloaded_alt_pkey->type == NID_hss) {
+            /* Create a temporary context */
+            tmpctx = EVP_PKEY_CTX_new(preloaded_alt_pkey, NULL);
+            if (tmpctx == NULL) {
+               BIO_printf(bio_err, "Could not create context.\n");
+               goto err;
+            }
+
+            /* Send the control string. */
+            if (EVP_PKEY_CTX_ctrl_str(tmpctx, "private_key_file", alt_keyfile) <= 0) {
+                BIO_printf(bio_err, "Couldn't set HSS private key file.\n");
+                goto err;
+            }
+
+            /* All the work for the tmpctx is done. */
+            EVP_PKEY_CTX_free(tmpctx);
+            tmpctx = NULL;
+        }
+    }
+    ret = 0;
+
+err:
+    NCONF_free(conf);
+    if (tmpctx) {
+        EVP_PKEY_CTX_free(tmpctx);
+    }
+    if (free_alt_key && alt_key) {
+        OPENSSL_free(alt_key);
+    }
+
+    return ret;
+}
+/* ISARA: END */
+
 /*
  * This function is used to statisfy the callback request from the EST
  * stack when a simple enrollment request needs to be serviced.
@@ -2141,6 +2286,11 @@ BIO * ossl_simple_enroll(const char *p10buf, int p10len) {
     DB_ATTR db_attr;
     BIO *retval = NULL;
 
+    /* ISARA: BEGIN */
+    char *alt_md = NULL;
+    const EVP_MD *alt_dgst = NULL;
+    /* ISARA: END */
+
     conf = NULL;
     key = NULL;
     section = NULL;
@@ -2487,6 +2637,29 @@ BIO * ossl_simple_enroll(const char *p10buf, int p10len) {
         goto err;
     }
 
+    /* ISARA: BEGIN */
+    if (preloaded_alt_pkey != NULL) {
+        if ((alt_md == NULL)
+                && ((alt_md = NCONF_get_string(conf, section, ENV_ALT_DEFAULT_MD)) == NULL)) {
+            alt_md = "default";
+        }
+
+        if (!strcmp(alt_md, "default")) {
+            int def_nid = 0;
+            if (EVP_PKEY_get_default_digest_nid(preloaded_alt_pkey, &def_nid) <= 0) {
+                BIO_puts(bio_err, "no default alt digest\n");
+                goto err;
+            }
+            alt_md = (char *) OBJ_nid2sn(def_nid);
+        }
+
+        if ((alt_dgst = EVP_get_digestbyname(alt_md)) == NULL) {
+            BIO_printf(bio_err, "%s is an unsupported message digest type\n", alt_md);
+            goto err;
+        }
+    }
+    /* ISARA: END */
+
     if (req) {
         if ((email_dn == 1)
                 && ((tmp_email_dn = NCONF_get_string(conf, section,
@@ -2497,6 +2670,12 @@ BIO * ossl_simple_enroll(const char *p10buf, int p10len) {
         if (verbose)
             BIO_printf(bio_err, "message digest is %s\n",
                     OBJ_nid2ln(dgst->type));
+            /* ISARA: BEGIN */
+            if (alt_dgst != NULL) {
+                BIO_printf(bio_err, "Alt message digest is %s\n",
+                        OBJ_nid2ln(alt_dgst->type));
+            }
+            /* ISARA: END */
         if ((policy == NULL)
                 && ((policy = NCONF_get_string(conf, section, ENV_POLICY))
                         == NULL)) {
@@ -2596,7 +2775,7 @@ BIO * ossl_simple_enroll(const char *p10buf, int p10len) {
 
         if (inptr != NULL) {
             total++;
-            j = certify(&x, inptr, pkey, x509p, dgst, sigopts, attribs, db,
+            j = certify(&x, inptr, pkey, preloaded_alt_pkey /*ISARA*/, x509p, dgst, alt_dgst /*ISARA*/, sigopts, attribs, db,
                     serial, subj, chtype, multirdn, email_dn, startdate,
                     enddate, days, batch, extensions, conf, verbose, certopt,
                     nameopt, default_op, ext_copy, selfsign, p10len);
diff --git a/example/server/ossl_srv.h b/example/server/ossl_srv.h
index 5d5edf1..5f3e483 100644
--- a/example/server/ossl_srv.h
+++ b/example/server/ossl_srv.h
@@ -12,5 +12,9 @@
 #define HEADER_OSSL_SRV_H 
 
 BIO * ossl_simple_enroll(unsigned char *p10buf, int p10len);
+/* ISARA: BEGIN */
+int ossl_preload_alt_key();
+void ossl_free_preloaded_alt_key();
+/* ISARA: END */
 
 #endif
diff --git a/example/server/runserver.sh b/example/server/runserver.sh
index cf15e49..ddd87dd 100755
--- a/example/server/runserver.sh
+++ b/example/server/runserver.sh
@@ -6,4 +6,4 @@ export EST_CACERTS_RESP=./estCA/cacert.crt
 export EST_OPENSSL_CACONFIG=./estExampleCA.cnf
 #export EST_CSR_ATTR="MGwGBysGAQEBARYwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEwJwYDiDcCMSAGA4g3AxMZUGFyc2UgU0VUIGFzIDIuOTk5LjIgZGF0YQYJKyQDAwIIAQELBglghkgBZQMEAgI="
 
-./estserver -c estCA/private/estservercertandkey.pem -k estCA/private/estservercertandkey.pem -r estrealm -v
+./estserver -c estCA/private/estservercertandkey.pem -k estCA/private/estservercertandkey.pem -q estCA/private/estserver2.pem -r estrealm -v
diff --git a/example/util/utils.c b/example/util/utils.c
index 688aa75..ebf7a8f 100644
--- a/example/util/utils.c
+++ b/example/util/utils.c
@@ -124,6 +124,78 @@ unsigned char *BIO_copy_data(BIO *out, int *data_lenp) {
     return data;
 }
 
+/* ISARA: BEGIN */
+struct param {
+    char *key;
+    char *value;
+};
+
+char *generate_private_HSS_key (pem_password_cb *cb)
+{
+    struct param opts[] = {
+        { "winternitz_value", "8" },
+        { "tree_height", "10" },
+        { NULL, NULL }
+    };
+    struct param *popts = opts;
+    char *key_data = NULL;
+    EVP_PKEY_CTX *ctx = NULL;
+    EVP_PKEY *pkey = NULL;
+
+    ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HSS, NULL);
+    if (!ctx) {
+        ossl_dump_ssl_errors();
+        EST_LOG_ERR("Error creating pkey context for id %d", EVP_PKEY_HSS);
+        goto end;
+    }
+
+    if (EVP_PKEY_keygen_init(ctx) <= 0) {
+        EST_LOG_ERR("Error initializing keygen for id %d", EVP_PKEY_HSS);
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    if (popts != NULL) {
+        while (popts->key != NULL) {
+            if (EVP_PKEY_CTX_ctrl_str(ctx, popts->key, popts->value) <= 0) {
+                EST_LOG_ERR("Error setting params %s = %s", popts->key, popts->value);
+                ossl_dump_ssl_errors();
+                goto end;
+            }
+            popts++;
+        }
+
+    }
+
+    if (EVP_PKEY_keygen(ctx, &pkey) <= 0) {
+        EST_LOG_ERR("Error doing keygen for id %d", EVP_PKEY_HSS);
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    do {
+        BIO *out = BIO_new(BIO_s_mem());
+        if (!out) {
+            break;
+        }
+        PEM_write_bio_PrivateKey(out, pkey, cb ? EST_PRIVATE_KEY_ENC : NULL, NULL, 0, cb, NULL);
+        key_data = (char *)BIO_copy_data(out, NULL);
+        BIO_free(out);
+        if (key_data && !strstr(key_data, "-----BEGIN PRIVATE KEY-----")) {
+            // happens if passphrase entered via STDIN does not verify or has less than 4 characters
+            free(key_data);
+            key_data = NULL;
+        }
+    } while (cb && !key_data);
+
+end:
+    EVP_PKEY_free(pkey);
+    EVP_PKEY_CTX_free(ctx);
+
+    return (key_data);
+}
+/* ISARA: END */
+
 char *generate_private_RSA_key (int key_size, pem_password_cb *cb)
 {
     char *key_data = NULL;
@@ -285,3 +357,70 @@ EVP_PKEY *read_private_key(const char *key_file, pem_password_cb *cb)
 
     return (priv_key);
 }
+
+/* ISARA: BEGIN */
+ENGINE *setup_engine(const char *engine)
+{
+    ENGINE *e = NULL;
+    if ((e = ENGINE_by_id(engine)) == NULL) {
+        EST_LOG_ERR("Invalid engine \"%s\"", engine);
+        return NULL;
+    }
+
+    if (!ENGINE_init(e)) {
+        EST_LOG_ERR("The engine did not initialize correctly");
+        ENGINE_free(e);
+        return NULL;
+    }
+
+    if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+        EST_LOG_ERR("Unable to use this engine");
+        ENGINE_free(e);
+        return NULL;
+    }
+
+    EST_LOG_INFO("Engine \"%s\" set", ENGINE_get_id(e));
+    return e;
+}
+
+void release_engine(ENGINE *e)
+{
+    if (e != NULL) {
+        /* Free our "structural" reference. */
+        ENGINE_free(e);
+    }
+}
+
+int set_pkey_filename(EVP_PKEY *pkey, const char *filename) {
+    int rv = EST_ERR_X509_PUBKEY;
+    EVP_PKEY_CTX *tmpctx = NULL;
+
+    if (pkey->type == NID_hss) {
+        /* Create a temporary context */
+        tmpctx = EVP_PKEY_CTX_new(pkey, NULL);
+        if (tmpctx == NULL) {
+            EST_LOG_ERR("Could not create context");
+            goto err;
+        }
+
+        /* Send the control string. */
+        if (EVP_PKEY_CTX_ctrl_str(tmpctx, "private_key_file", filename) <= 0) {
+            EST_LOG_ERR("Couldn't set HSS private key file.");
+            goto err;
+        }
+
+        /* All the work for the tmpctx is done. */
+        EVP_PKEY_CTX_free(tmpctx);
+        tmpctx = NULL;
+    }
+
+    rv = EST_ERR_NONE;
+
+err:
+    if (tmpctx != NULL) {
+        EVP_PKEY_CTX_free(tmpctx);
+    }
+
+    return rv;
+}
+/* ISARA: END */
diff --git a/example/util/utils.h b/example/util/utils.h
index 644bb53..2a6b7f9 100644
--- a/example/util/utils.h
+++ b/example/util/utils.h
@@ -23,5 +23,11 @@ EVP_PKEY *load_private_key (const unsigned char *key, int key_len, int format, p
 char *private_key_to_PEM (const EVP_PKEY* pkey, pem_password_cb *cb);
 char *generate_private_EC_key (int curve_nid, pem_password_cb *cb);
 char *generate_private_RSA_key (int key_size, pem_password_cb *cb);
+/* ISARA: BEGIN */
+ENGINE *setup_engine(const char *engine);
+void release_engine(ENGINE *e);
+char *generate_private_HSS_key (pem_password_cb *cb);
+int set_pkey_filename(EVP_PKEY *pkey, const char *filename);
+/* ISARA: END */
 #endif
 
diff --git a/java/jni/client.c b/java/jni/client.c
index a6954cd..693be3f 100644
--- a/java/jni/client.c
+++ b/java/jni/client.c
@@ -689,7 +689,7 @@ static jint send_enroll_request (
 	 * when TLS auth isn't enabled from the layer above us.  Same goes
 	 * for HTTP auth.
 	 */
-	rv = est_client_set_auth(ectx, l_http_user, l_http_pwd, tls_cert, tls_key );
+	rv = est_client_set_auth(ectx, l_http_user, l_http_pwd, tls_cert, tls_key, NULL /*ISARA*/ );
 	if (rv != EST_ERR_NONE) {
 		est_client_raise_exception(env, EST_CLASS_ENROLL_EXCEPTION,
 				"est_client_set_auth failed", rv, 0);
@@ -733,12 +733,12 @@ static jint send_enroll_request (
 		/*
 	     * ReEnroll the old X509 cert with the EST server
 	     */
-		rv = est_client_reenroll(ectx, old_cert, &pkcs7_len, l_priv_key);
+		rv = est_client_reenroll(ectx, old_cert, &pkcs7_len, l_priv_key, NULL /*ISARA*/);
 	} else {
 		/*
 	     * Enroll the CSR with the EST server
 	     */
-		rv = est_client_enroll_csr(ectx, req, &pkcs7_len, l_priv_key);
+		rv = est_client_enroll_csr(ectx, req, &pkcs7_len, l_priv_key, NULL /*ISARA*/);
 	}
 	switch (rv) {
 	case EST_ERR_CA_ENROLL_RETRY:
diff --git a/mpkac_test.sh b/mpkac_test.sh
new file mode 100755
index 0000000..4850c8e
--- /dev/null
+++ b/mpkac_test.sh
@@ -0,0 +1,137 @@
+#!/bin/bash
+
+PATH=/usr/local/ssl/bin:$PATH
+
+# Get CA cert
+rm 443-root.crt
+wget http://test-pqpki.com/443-root.crt
+
+export EST_OPENSSL_CACERT=`realpath 443-root.crt`
+
+pushd example/client
+
+export OUTPUT_DIR=/tmp/EST
+export OUTPUT_PKCS7_CACERT=$OUTPUT_DIR/cacert-0-0.pkcs7
+export OUTPUT_PEM_CACERT=$OUTPUT_DIR/cacert-0-0.pem
+export OUTPUT_PKCS7_CERT=$OUTPUT_DIR/cert-0-0.pkcs7
+export OUTPUT_PEM_CERT=$OUTPUT_DIR/cert-0-0.pem
+
+export EST_HOST=test-pqpki.com
+export EST_PORT=443
+# Try it with IPv4 or IPv6 addresses if you like:
+#export EST_HOST=18.217.192.8
+#export EST_HOST=2600:1f16:61c:2f02:aa2c:84ac:3758:922e
+
+export VERBOSE_FLAG=
+
+rm -rf $OUTPUT_DIR
+mkdir -p $OUTPUT_DIR
+
+function print_and_verify_cert()
+{
+	CERT=$1
+	CA_CERT=$2
+
+	# Print new cert
+	openssl x509 -engine qs_sig -in $CERT -noout -text
+
+	# Verify the cert's classical signature
+	openssl verify -CAfile $CA_CERT $CERT || exit 1
+	echo "Classical verification success"
+
+	# Verify the cert's alt signature
+	openssl x509QSVerify -engine qs_sig -root $CA_CERT -untrusted $CERT  -cert $CERT || exit 1
+	echo "Alt Signature verification success"
+}
+
+# Fetch CA cert
+./estclient $VERBOSE_FLAG -g -u estuser -h estpwd -s $EST_HOST -p $EST_PORT -o $OUTPUT_DIR || exit 1
+echo "Fetch CA cert success"
+
+########################################
+# estclient tests
+########################################
+
+# print CA cert
+openssl base64 -d -in $OUTPUT_PKCS7_CACERT | openssl pkcs7 -engine qs_sig -inform DER -text -print_certs -noout
+
+# Convert PKCS7 CA Cert to PEM
+openssl base64 -d -in $OUTPUT_PKCS7_CACERT | openssl pkcs7 -inform DER  -print_certs -out $OUTPUT_PEM_CACERT || exit 1
+
+# Enroll a new cert with new key
+./estclient $VERBOSE_FLAG -e  --common-name "Newly Enrolled MPKAC" -u estuser -h estpwd -s $EST_HOST -p $EST_PORT -o $OUTPUT_DIR --pem-output || exit 1
+print_and_verify_cert $OUTPUT_PEM_CERT $OUTPUT_PEM_CACERT
+echo "New cert enrollment success"
+
+# Copy aside the private keys
+cp $OUTPUT_DIR/key-x-x.pem $OUTPUT_DIR/savekey.pem
+cp $OUTPUT_DIR/alt-key-x-x.pem $OUTPUT_DIR/alt-savekey.pem
+cp $OUTPUT_PEM_CERT $OUTPUT_DIR/savecert.pem
+
+# Re-enrol the cert
+./estclient $VERBOSE_FLAG -r -u estuser -h estpwd -s $EST_HOST -p $EST_PORT -c $OUTPUT_DIR/savecert.pem -k $OUTPUT_DIR/savekey.pem --k-alt $OUTPUT_DIR/alt-savekey.pem -o $OUTPUT_DIR --pem-output || exit 1
+print_and_verify_cert $OUTPUT_PEM_CERT $OUTPUT_PEM_CACERT
+echo "Cert re-enrollment success"
+
+# Enroll a new cert using the previous cert and keys for client auth and the previous cert signing keys.
+./estclient $VERBOSE_FLAG -e  --common-name "Newly Enrolled MPKAC 2" -u estuser -h estpwd -s $EST_HOST -p $EST_PORT -c $OUTPUT_DIR/savecert.pem -k $OUTPUT_DIR/savekey.pem --k-alt $OUTPUT_DIR/alt-savekey.pem -x $OUTPUT_DIR/savekey.pem --x-alt $OUTPUT_DIR/alt-savekey.pem -o $OUTPUT_DIR --pem-output || exit 1
+print_and_verify_cert $OUTPUT_PEM_CERT $OUTPUT_PEM_CACERT
+echo "New cert enrollment with client auth success"
+
+# Generate keys and CSR using openssl
+openssl genpkey -engine qs_sig -algorithm hss -pkeyopt winternitz_value:8 -pkeyopt tree_height:5 -out $OUTPUT_DIR/openssl_hss_key.pem || exit 1
+openssl ecparam -out $OUTPUT_DIR/ecdsa_mpkac_parameters.pem -name secp521r1 || exit 1
+openssl req         -new -newkey ec:$OUTPUT_DIR/ecdsa_mpkac_parameters.pem -keyout $OUTPUT_DIR/openssl_ecdsa_key.pem -out $OUTPUT_DIR/openssl_ecdsa_req.pem -config isara_req.cfg -nodes || exit 1
+openssl reqQSExtend -engine qs_sig -reqin $OUTPUT_DIR/openssl_ecdsa_req.pem -reqout $OUTPUT_DIR/openssl_mpkac_req.pem -privin $OUTPUT_DIR/openssl_ecdsa_key.pem -privqs $OUTPUT_DIR/openssl_hss_key.pem || exit 1
+
+# Enroll a new cert with keys from openssl
+./estclient $VERBOSE_FLAG -e  --common-name "Newly Enrolled MPKAC from openssl keys" -u estuser -h estpwd -s $EST_HOST -p $EST_PORT -x $OUTPUT_DIR/openssl_ecdsa_key.pem --x-alt $OUTPUT_DIR/openssl_hss_key.pem -o $OUTPUT_DIR --pem-output || exit 1
+print_and_verify_cert $OUTPUT_PEM_CERT $OUTPUT_PEM_CACERT
+echo "New cert enrollment with openssl keys success"
+
+# Enroll a new cert with pure ECDSA CSR from openssl. The cert won't contain
+# a Subject Alt Public Key Info, but it will contain an Alt Signature from the
+# CA. MPKA cert and keys are used for client auth.
+./estclient $VERBOSE_FLAG -e -u estuser -h estpwd -s $EST_HOST -p $EST_PORT -y $OUTPUT_DIR/openssl_ecdsa_req.pem -c $OUTPUT_DIR/savecert.pem -k $OUTPUT_DIR/savekey.pem --k-alt $OUTPUT_DIR/alt-savekey.pem -o $OUTPUT_DIR --pem-output || exit 1
+print_and_verify_cert $OUTPUT_PEM_CERT $OUTPUT_PEM_CACERT
+echo "New cert enrollment with openssl ECDSA CSR success"
+
+# Copy aside non-MPKA cert
+cp $OUTPUT_PEM_CERT $OUTPUT_DIR/ecdsa_savecert.pem
+
+# Re-enrol the non-MPKA cert using non-MPKA cert for client auth
+./estclient $VERBOSE_FLAG -r -u estuser -h estpwd -s $EST_HOST -p $EST_PORT -c $OUTPUT_DIR/ecdsa_savecert.pem -k $OUTPUT_DIR/openssl_ecdsa_key.pem -o $OUTPUT_DIR --pem-output || exit 1
+print_and_verify_cert $OUTPUT_PEM_CERT $OUTPUT_PEM_CACERT
+echo "Cert re-enrollment success"
+
+# Enroll a new MPKA cert using the previous ECDSA cert and key for client auth and the previous ECDSA signing keys, HSS key will be generated.
+./estclient $VERBOSE_FLAG -e  --common-name "Newly Enrolled MPKAC 3" -u estuser -h estpwd -s $EST_HOST -p $EST_PORT -c $OUTPUT_DIR/ecdsa_savecert.pem -k $OUTPUT_DIR/openssl_ecdsa_key.pem -x $OUTPUT_DIR/openssl_ecdsa_key.pem -o $OUTPUT_DIR --pem-output || exit 1
+print_and_verify_cert $OUTPUT_PEM_CERT $OUTPUT_PEM_CACERT
+echo "New cert enrollment from ECDSA cert with client auth success"
+
+# Enroll a new cert with MPKA CSR from openssl.  MPKA cert and keys are used
+# for client auth.
+./estclient $VERBOSE_FLAG -e -u estuser -h estpwd -s $EST_HOST -p $EST_PORT -y $OUTPUT_DIR/openssl_mpkac_req.pem -c $OUTPUT_DIR/savecert.pem -k $OUTPUT_DIR/savekey.pem --k-alt $OUTPUT_DIR/alt-savekey.pem -o $OUTPUT_DIR --pem-output || exit 1
+print_and_verify_cert $OUTPUT_PEM_CERT $OUTPUT_PEM_CACERT
+echo "New cert enrollment with openssl MPKA CSR success"
+
+
+########################################
+# estclient-simple tests
+########################################
+
+popd
+pushd example/client-simple
+
+# Enroll new cert using estclient-simple
+./estclient_simple -u estuser -h estpwd -s $EST_HOST -p $EST_PORT || exit 1
+# convert estclient-simple cert to PEM
+openssl base64 -d -in cert-b64.pkcs7 | openssl pkcs7 -inform DER  -print_certs -out $OUTPUT_DIR/estclient-simple.pem || exit 1
+print_and_verify_cert $OUTPUT_DIR/estclient-simple.pem $OUTPUT_PEM_CACERT
+echo "New estclient_simple cert enrollment success"
+
+echo
+echo "--------------------"
+echo "Success!!"
+echo "--------------------"
+echo
\ No newline at end of file
diff --git a/src/est/Makefile.am b/src/est/Makefile.am
index ee2d2db..ff88417 100644
--- a/src/est/Makefile.am
+++ b/src/est/Makefile.am
@@ -2,6 +2,7 @@ lib_LTLIBRARIES = libest.la
 AM_CFLAGS = -I$(SSL_CFLAGS) -I../.. -I$(SAFEC_CFLAGS)/include $(LIBCURL_CFLAGS)
 libest_la_LDFLAGS = -release $(PACKAGE_VERSION) 
 libest_la_SOURCES = est.c est_client.c est_server.c est_server_http.c \
+                    est_client_alt_csr.c est_client_alt_cert.c est_server_alt.c \
                     est_proxy.c est_client_http.c est_ossl_util.c est_client_proxy.c
 
 libest_la_LIBADD = $(SAFEC_LDFLAGS)
diff --git a/src/est/Makefile.in b/src/est/Makefile.in
index 2525cbd..d606dcf 100644
--- a/src/est/Makefile.in
+++ b/src/est/Makefile.in
@@ -135,8 +135,9 @@ LTLIBRARIES = $(lib_LTLIBRARIES)
 am__DEPENDENCIES_1 =
 libest_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
 am_libest_la_OBJECTS = est.lo est_client.lo est_server.lo \
-	est_server_http.lo est_proxy.lo est_client_http.lo \
-	est_ossl_util.lo est_client_proxy.lo
+	est_server_http.lo est_client_alt_csr.lo \
+	est_client_alt_cert.lo est_server_alt.lo est_proxy.lo \
+	est_client_http.lo est_ossl_util.lo est_client_proxy.lo
 libest_la_OBJECTS = $(am_libest_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -335,6 +336,7 @@ lib_LTLIBRARIES = libest.la
 AM_CFLAGS = -I$(SSL_CFLAGS) -I../.. -I$(SAFEC_CFLAGS)/include $(LIBCURL_CFLAGS)
 libest_la_LDFLAGS = -release $(PACKAGE_VERSION) 
 libest_la_SOURCES = est.c est_client.c est_server.c est_server_http.c \
+                    est_client_alt_csr.c est_client_alt_cert.c est_server_alt.c \
                     est_proxy.c est_client_http.c est_ossl_util.c est_client_proxy.c
 
 libest_la_LIBADD = $(SAFEC_LDFLAGS)
@@ -421,11 +423,14 @@ distclean-compile:
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est_client.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est_client_alt_cert.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est_client_alt_csr.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est_client_http.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est_client_proxy.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est_ossl_util.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est_proxy.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est_server.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est_server_alt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est_server_http.Plo@am__quote@
 
 .c.o:
diff --git a/src/est/est.c b/src/est/est.c
index c4afc8a..a0f47e5 100644
--- a/src/est/est.c
+++ b/src/est/est.c
@@ -1848,4 +1848,3 @@ int est_strcasecmp_s (char *s1, char *s2)
 
     return diff;
 }
-
diff --git a/src/est/est.h b/src/est/est.h
index 67cac82..200d363 100644
--- a/src/est/est.h
+++ b/src/est/est.h
@@ -41,7 +41,13 @@ extern "C" {
 #define EST_MAX_SERVERNAME_LEN    (255)
 #define EST_PORTNUM_LEN          (sizeof(int))
 #define EST_MAX_SERVERNAME_AND_PORT_LEN    (EST_MAX_SERVERNAME_LEN+EST_PORTNUM_LEN)
+/* ISARA: BEGIN */
+/*
 #define EST_MAX_CLIENT_CERT_LEN  (4096)
+*/
+/* Dual-key certificates are large, so increase maximum size */
+#define EST_MAX_CLIENT_CERT_LEN  (262144)
+/* ISARA: END */
 #define EST_MAX_PATH_SEGMENT_LEN (128)
 
 typedef enum {
@@ -392,7 +398,7 @@ LIBEST_API EST_CTX * est_server_init(unsigned char *ca_chain, int ca_chain_len,
                           unsigned char *cacerts_resp_chain, int cacerts_resp_chain_len,
 			  EST_CERT_FORMAT cert_format,
                           char *http_realm, X509 *tls_cert,
-                          EVP_PKEY *tls_key);
+                          EVP_PKEY *tls_key, EVP_PKEY *tls_id_alt_key /*ISARA*/);
 LIBEST_API EST_CTX * est_proxy_init(unsigned char *ca_chain, int ca_chain_len,
                          unsigned char *cacerts_resp_chain, int cacerts_resp_chain_len,
 			 EST_CERT_FORMAT cert_format,
@@ -433,7 +439,7 @@ LIBEST_API EST_CTX *est_client_init(unsigned char *ca_chain, int ca_chain_len,
                          EST_CERT_FORMAT cert_format,
                          int (*cert_verify_cb)(X509 *, int));
 LIBEST_API EST_ERROR est_client_set_auth(EST_CTX *ctx, const char *uid, const char *pwd,
-                              X509 *client_cert, EVP_PKEY *private_key);
+                              X509 *client_cert, EVP_PKEY *private_key, EVP_PKEY *alt_private_key /* ISARA */);
 LIBEST_API EST_ERROR est_client_set_auth_cred_cb(EST_CTX *ctx, auth_credentials_cb);
 LIBEST_API EST_ERROR est_client_set_server(EST_CTX *ctx, const char *server, int port, char *path_segment);
 LIBEST_API EST_ERROR est_client_set_proxy(EST_CTX *ctx,
@@ -446,11 +452,11 @@ LIBEST_API EST_ERROR est_client_set_proxy(EST_CTX *ctx,
 LIBEST_API EST_ERROR est_client_provision_cert(EST_CTX *ctx, char *cn, 
 	                            int *pkcs7_len,
 				    int *ca_cert_len,
-                                    EVP_PKEY *new_public_key);
+                                    EVP_PKEY *new_public_key, EVP_PKEY *new_alt_public_key /*ISARA*/);
 LIBEST_API EST_ERROR est_client_enroll(EST_CTX *ctx, char *cn, int *pkcs7_len,
-                            EVP_PKEY *new_public_key);
-LIBEST_API EST_ERROR est_client_enroll_csr(EST_CTX *ctx, X509_REQ *csr, int *pkcs7_len, EVP_PKEY *priv_key);
-LIBEST_API EST_ERROR est_client_reenroll(EST_CTX *ctx, X509 *cert, int *pkcs7_len, EVP_PKEY *priv_key);
+                            EVP_PKEY *new_public_key, EVP_PKEY *new_alt_public_key /*ISARA*/);
+LIBEST_API EST_ERROR est_client_enroll_csr(EST_CTX *ctx, X509_REQ *csr, int *pkcs7_len, EVP_PKEY *priv_key, EVP_PKEY *alt_priv_key /*ISARA*/);
+LIBEST_API EST_ERROR est_client_reenroll(EST_CTX *ctx, X509 *cert, int *pkcs7_len, EVP_PKEY *priv_key, EVP_PKEY *alt_priv_key /*ISARA*/);
 LIBEST_API EST_ERROR est_client_copy_enrolled_cert(EST_CTX *ctx, unsigned char *pkcs7);
 LIBEST_API EST_ERROR est_client_get_csrattrs(EST_CTX *ctx, unsigned char **csr_data, int *csr_len);
 LIBEST_API EST_ERROR est_client_get_cacerts(EST_CTX *ctx, int *ca_certs_len);
@@ -499,6 +505,22 @@ LIBEST_API X509_REQ *est_read_x509_request(unsigned char *csr, int csr_len,
 LIBEST_API EVP_PKEY *est_load_key(unsigned char *key, int key_len, int format);
 LIBEST_API int est_convert_p7b64_to_pem(unsigned char *certs_p7, int certs_len, unsigned char **pem);
 
+/* ISARA: BEGIN */
+/*
+ * Add an alternative public key to the CSR.
+ */
+LIBEST_API EST_ERROR est_client_csr_add_alt_pubkey(X509_REQ *csr, EVP_PKEY *alt_pub_key);
+
+/*
+ * Add the alternative extensions to the certificate.
+ *
+ * This must be called immediately before signing the certificate. If the
+ * certificate is modified in any way after adding the alternative extensions
+ * and before signing, the alternative signature will be invalid.
+ */
+LIBEST_API EST_ERROR est_server_cert_add_alt_extensions(X509 *cert, X509_REQ *csr, EVP_PKEY *alt_pkey, const EVP_MD *alt_md);
+/* ISARA: END */
+
 /*
  * These are helper macros that an application can use
  * to initialize/de-initialize OpenSSL.  
diff --git a/src/est/est_client.c b/src/est/est_client.c
index 06e2d22..d96ea92 100644
--- a/src/est/est_client.c
+++ b/src/est/est_client.c
@@ -24,7 +24,10 @@
 #include <netinet/in.h>
 #include <netdb.h>
 #else
+#include <stdio.h>
+#ifndef snprintf
 #define snprintf _snprintf
+#endif
 #include <Ws2tcpip.h>
 #include <BaseTsd.h>
 #include <WinDef.h>
@@ -35,6 +38,7 @@
 #include <openssl/ssl.h>
 #include <openssl/rand.h>
 #include "est.h"
+#include "est_client_alt.h" /* ISARA */
 #include "est_locl.h"
 #include "est_ossl_util.h"
 #include "safe_mem_lib.h"
@@ -62,7 +66,7 @@ int e_ctx_ssl_exdata_index = SSL_EXDATA_INDEX_INVALID;
  *
  * Returns 0 on success
  */
-int est_client_set_cert_and_key (SSL_CTX *ctx, X509 *cert, EVP_PKEY *key)
+int est_client_set_cert_and_key (SSL_CTX *ctx, X509 *cert, EVP_PKEY *key, EVP_PKEY *alt_key /* ISARA */)
 {
 
     if (SSL_CTX_use_certificate(ctx, cert) <= 0) {
@@ -78,6 +82,16 @@ int est_client_set_cert_and_key (SSL_CTX *ctx, X509 *cert, EVP_PKEY *key)
         return 1;
     }
 
+    /* ISARA: BEGIN */
+    if (alt_key) {
+        if (SSL_CTX_use_ALTPrivateKey(ctx, alt_key) <= 0) {
+            EST_LOG_ERR("Unable to set alt private key");
+            ossl_dump_ssl_errors();
+            return 1;
+        }
+    }
+    /* ISARA: END */
+
     /*
      * Verify the key matches the cert
      */
@@ -89,17 +103,29 @@ int est_client_set_cert_and_key (SSL_CTX *ctx, X509 *cert, EVP_PKEY *key)
     return 0;
 }
 
-
 /*
  * Sign an X509 certificate request using the digest and the key passed.
  * Returns OpenSSL error code from X509_REQ_sign_ctx();
  */
-static int est_client_X509_REQ_sign (X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)
+static int est_client_X509_REQ_sign (X509_REQ *x, EVP_PKEY *pkey, EVP_PKEY *alt_pkey /*ISARA*/, const EVP_MD *md)
 {
     int rv;
     EVP_PKEY_CTX *pkctx = NULL;
     EVP_MD_CTX mctx;
 
+    /* ISARA: BEGIN */
+    /*
+     * Sign CSR with the alt key prior to signing it with the classical key
+     */
+    if (alt_pkey != NULL) {
+        rv = est_client_req_alt_sign(x, alt_pkey);
+        if (rv != EST_ERR_NONE) {
+            EST_LOG_ERR("Unable to add alt signature to X509 cert request");
+            return rv;
+        }
+    }
+    /* ISARA: END */
+
     EVP_MD_CTX_init(&mctx);
 
     if (!EVP_DigestSignInit(&mctx, &pkctx, md, NULL, pkey)) {
@@ -128,13 +154,14 @@ static int est_client_X509_REQ_sign (X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *
  * Parameters:
  *	req:	pointer to the buffer that is to hold the x509 request header
  *	pkey:   public key to be placed into the x509 request
+ *	alt_pkey: Alternative public key to be placed into the x509 request
  *	cn:     Common Name to be placed into the x509 request
  *      cp:     challenge password to be placed into the x509 header
  *
  * Return value:
  *	EST_ERR_NONE if success
  */
-static EST_ERROR populate_x509_request (EST_CTX *ctx, X509_REQ *req, EVP_PKEY *pkey, 
+static EST_ERROR populate_x509_request (EST_CTX *ctx, X509_REQ *req, EVP_PKEY *pkey, EVP_PKEY *alt_pkey /*ISARA*/,
 					char *cn, char *cp)
 {
     X509_NAME *subj;
@@ -181,6 +208,17 @@ static EST_ERROR populate_x509_request (EST_CTX *ctx, X509_REQ *req, EVP_PKEY *p
         return (EST_ERR_X509_PUBKEY);
     }
 
+    /* ISARA: BEGIN */
+    /* Add the alt public key to the CSR */
+    if (alt_pkey != NULL) {
+        if (est_client_csr_add_alt_pubkey(req, alt_pkey) != EST_ERR_NONE) {
+            EST_LOG_ERR("Failed to set alt public key");
+            ossl_dump_ssl_errors();
+            return (EST_ERR_X509_PUBKEY);
+        }
+    }
+    /* ISARA: END */
+
     return (EST_ERR_NONE);
 }
 
@@ -192,12 +230,13 @@ static EST_ERROR populate_x509_request (EST_CTX *ctx, X509_REQ *req, EVP_PKEY *p
  *	cn:	Common Name to put into the certificate.
  *	cp:     TLS unique ID for the SSL session, becomes the challenge password
  *	pkey:	Private key to use for signing the request.
+ *	alt_pkey: Alternative Private key to use for signing the request.
  *
  * Return value:
  *	EST_ERR_NONE if success
  */
 static EST_ERROR est_generate_pkcs10 (EST_CTX *ctx, char *cn, char *cp, 
-	                              EVP_PKEY *pkey, X509_REQ **pkcs10)
+	                              EVP_PKEY *pkey, EVP_PKEY *alt_pkey /*ISARA*/, X509_REQ **pkcs10)
 {
     X509_REQ *req = NULL;
     EST_ERROR rv;
@@ -210,7 +249,7 @@ static EST_ERROR est_generate_pkcs10 (EST_CTX *ctx, char *cn, char *cp,
         return (EST_ERR_MALLOC);
     }
 
-    rv = populate_x509_request(ctx, req, pkey, cn, cp);
+    rv = populate_x509_request(ctx, req, pkey, alt_pkey /*ISARA*/, cn, cp);
     if (rv != EST_ERR_NONE) {
         X509_REQ_free(req);
         return (rv);
@@ -219,7 +258,7 @@ static EST_ERROR est_generate_pkcs10 (EST_CTX *ctx, char *cn, char *cp,
     /*
      * Sign the request
      */
-    ossl_rv = est_client_X509_REQ_sign(req, pkey, ctx->signing_digest);
+    ossl_rv = est_client_X509_REQ_sign(req, pkey, alt_pkey /*ISARA*/, ctx->signing_digest);
     if (!ossl_rv) {
         EST_LOG_ERR("Unable to sign X509 cert request");
         X509_REQ_free(req);
@@ -262,6 +301,12 @@ static int est_client_cacert_verify_cb (int ok, X509_STORE_CTX *ctx)
                      X509_STORE_CTX_get_error_depth(ctx),
                      X509_verify_cert_error_string(cert_error));
     }
+    /* ISARA: BEGIN */
+    if (ok) {
+        /* Only verify the alt signature if the cert is otherwise acceptable */
+        ok = est_client_cert_verify_alt_signature(ctx);
+    }
+    /* ISARA: END */
     return (ok);
 }
 
@@ -1625,6 +1670,39 @@ static EST_ERROR est_client_check_x509 (X509 *cert)
     return (EST_ERR_NONE);
 }
 
+/* ISARA: BEGIN */
+static int X509_check_alt_private_key(X509 *x, EVP_PKEY *k)
+{
+    EVP_PKEY *xk = NULL;
+    int ret = 0;
+
+    xk = est_client_cert_get_alt_pubkey(x);
+
+    if (xk)
+        ret = EVP_PKEY_cmp(xk, k);
+    else
+        ret = -2;
+
+    switch (ret) {
+    case 1:
+        break;
+    case 0:
+        X509err(X509_F_X509_CHECK_PRIVATE_KEY, X509_R_KEY_VALUES_MISMATCH);
+        break;
+    case -1:
+        X509err(X509_F_X509_CHECK_PRIVATE_KEY, X509_R_KEY_TYPE_MISMATCH);
+        break;
+    case -2:
+        X509err(X509_F_X509_CHECK_PRIVATE_KEY, X509_R_UNKNOWN_KEY_TYPE);
+    }
+    if (xk)
+        EVP_PKEY_free(xk);
+    if (ret > 0)
+        return 1;
+    return 0;
+}
+/* ISARA: END */
+
 /*
  * This function is used to clear any ChallengePassword
  * attributes in an X509 CSR.  This is used because when
@@ -1807,12 +1885,14 @@ static EST_ERROR est_client_enroll_req (EST_CTX *ctx, SSL *ssl, X509_REQ *req,
  *    pkcs7_len  pointer to an integer in which the length of the recieved
  *               pkcs7 response is placed.
  *    priv_key Pointer to the private key used to sign the CSR.
+ *    alt_priv_key Pointer to the alternative private key used to sign the
+ *                 multiple public-key algorithm CSR.
  *    reenroll Set to 1 to do a reenroll instead of an enroll
  *
  *  Returns EST_ERROR  
  */
 static EST_ERROR est_client_enroll_pkcs10 (EST_CTX *ctx, SSL *ssl, X509_REQ *csr,
-                                           int *pkcs7_len, EVP_PKEY *priv_key,
+                                           int *pkcs7_len, EVP_PKEY *priv_key, EVP_PKEY *alt_priv_key /*ISARA*/,
                                            int reenroll)
 {
     EST_ERROR    rv = EST_ERR_NONE;
@@ -1824,6 +1904,18 @@ static EST_ERROR est_client_enroll_pkcs10 (EST_CTX *ctx, SSL *ssl, X509_REQ *csr
      */
     est_client_clear_csr_pop(csr);
 
+    /* ISARA: BEGIN */
+    /* The Alt Signature Algorithm and Alt Signature Value attributes might
+     * already be set if this CSR was attempted to be registered already but
+     * didn't succeed, probably due to an authentication problem.  The POP
+     * attribute might have changed, so we have to remove and recalculate
+     * the signature-related attributes. */
+    rv = est_client_req_remove_alt_sig_attributes(csr);
+    if (rv != EST_ERR_NONE) {
+        return rv;
+    }
+    /* ISARA: END */
+
     /*
      * Get the PoP value from the TLS session and embed this into
      * the CSR if required.
@@ -1849,7 +1941,7 @@ static EST_ERROR est_client_enroll_pkcs10 (EST_CTX *ctx, SSL *ssl, X509_REQ *csr
     /*
      * Sign the CSR
      */
-    ossl_rv = est_client_X509_REQ_sign(csr, priv_key, ctx->signing_digest);
+    ossl_rv = est_client_X509_REQ_sign(csr, priv_key, alt_priv_key /*ISARA*/, ctx->signing_digest);
     if (!ossl_rv) {
         EST_LOG_ERR("Unable to sign X509 cert request");
         ossl_dump_ssl_errors();
@@ -1876,11 +1968,12 @@ static EST_ERROR est_client_enroll_pkcs10 (EST_CTX *ctx, SSL *ssl, X509_REQ *csr
     @param pkcs7_len pointer to an integer in which the length of the recieved
     pkcs7 response is placed.
     @param pkey The new client public key that is to be enrolled
+    @param alt_pkey The new client alternative public key that is to be enrolled
 
     @return EST_ERROR 
  */
 static EST_ERROR est_client_enroll_cn (EST_CTX *ctx, SSL *ssl, char *cn,
-                                         int *pkcs7_len, EVP_PKEY *pkey)
+                                         int *pkcs7_len, EVP_PKEY *pkey, EVP_PKEY *alt_pkey /*ISARA*/)
 {
     X509_REQ    *pkcs10 = NULL;
     EST_ERROR    rv = EST_ERR_NONE;
@@ -1896,7 +1989,7 @@ static EST_ERROR est_client_enroll_cn (EST_CTX *ctx, SSL *ssl, char *cn,
      */
     tls_uid = est_get_tls_uid(ssl, 1);
     if (tls_uid) {
-        rv = est_generate_pkcs10(ctx, cn, tls_uid, pkey, &pkcs10);
+        rv = est_generate_pkcs10(ctx, cn, tls_uid, pkey, alt_pkey /*ISARA*/, &pkcs10);
         free(tls_uid);
     } else {
         EST_LOG_ERR("Unable to obtain the TLS UID");
@@ -2536,6 +2629,12 @@ EST_ERROR est_client_connect (EST_CTX *ctx, SSL **ssl)
         rv = EST_ERR_FQDN_MISMATCH;
     }
 
+    /* ISARA: BEGIN */
+    if (rv == EST_ERR_NONE) {
+        EST_LOG_INFO("Established connection with ciphersuite %s", SSL_get_cipher_name(*ssl));
+    }
+    /* ISARA: END */
+
     return rv;
 }
 
@@ -2778,6 +2877,8 @@ EST_ERROR est_client_set_uid_pw (EST_CTX *ctx, const char *uid, const char *pwd)
     buffer.
     @param priv_key Pointer to the private key that will be used to sign the CSR,
     or NULL
+    @param alt_priv_key Pointer to the alternative private key that will be used to sign the
+    multiple public-key algorithm CSR, or NULL
  
     @return EST_ERROR
 
@@ -2811,10 +2912,11 @@ EST_ERROR est_client_set_uid_pw (EST_CTX *ctx, const char *uid, const char *pwd)
     the est_read_x509_request() helper function to convert the PEM/DER CSR into a
     valid X509_REQ pointer.
  */
-EST_ERROR est_client_enroll_csr (EST_CTX *ctx, X509_REQ *csr, int *pkcs7_len, EVP_PKEY *priv_key)
+EST_ERROR est_client_enroll_csr (EST_CTX *ctx, X509_REQ *csr, int *pkcs7_len, EVP_PKEY *priv_key, EVP_PKEY *alt_priv_key /*ISARA*/)
 {
     EST_ERROR rv;
     SSL *ssl = NULL;
+    int csr_has_alt_key = 0; /* ISARA */
 
     if (!ctx) {
         return (EST_ERR_NO_CTX);
@@ -2836,8 +2938,9 @@ EST_ERROR est_client_enroll_csr (EST_CTX *ctx, X509_REQ *csr, int *pkcs7_len, EV
         goto err;
     }
 
-    if (priv_key) {
-      rv = est_client_enroll_pkcs10(ctx, ssl, csr, pkcs7_len, priv_key, 0);
+    csr_has_alt_key = X509_REQ_get_attr_by_NID(csr, NID_alt_sigalg, -1) >= 0; /* ISARA */
+    if (priv_key && (!csr_has_alt_key || (csr_has_alt_key && alt_priv_key))/*ISARA*/) {
+      rv = est_client_enroll_pkcs10(ctx, ssl, csr, pkcs7_len, priv_key, alt_priv_key /*ISARA*/, 0);
     } else {
         rv = est_client_enroll_req(ctx, ssl, csr, pkcs7_len, 0);
     }
@@ -2865,7 +2968,7 @@ EST_ERROR est_client_enroll_csr (EST_CTX *ctx, X509_REQ *csr, int *pkcs7_len, EV
             goto err;
         }
 	if (priv_key) {
-	  rv = est_client_enroll_pkcs10(ctx, ssl, csr, pkcs7_len, priv_key, 0);
+	  rv = est_client_enroll_pkcs10(ctx, ssl, csr, pkcs7_len, priv_key, alt_priv_key /*ISARA*/, 0);
 	} else {
 	  rv = est_client_enroll_req(ctx, ssl, csr, pkcs7_len, 0);
 	}
@@ -2898,6 +3001,11 @@ err:
     client's key pair to be used in the simple enroll request .  The public
     key is included in the Certificate Signing Request (CSR) sent to the CA
     Server, and the private key is used to sign the request.
+    @param new_alt_public_key Pointer an EVP_PKEY structure that holds the
+    client's alternative key pair to be used in the simple enroll request .
+    The alternative public key is included in the Certificate Signing Request
+    (CSR) sent to the CA Server, and the alternative private key is used to
+    sign the request.
  
     @return EST_ERROR
 
@@ -2912,7 +3020,7 @@ err:
     from the context.
  */
 EST_ERROR est_client_enroll (EST_CTX *ctx, char *cn, int *pkcs7_len,
-                             EVP_PKEY *new_public_key)
+                             EVP_PKEY *new_public_key, EVP_PKEY *new_alt_public_key /*ISARA*/)
 {
     EST_ERROR rv;
     SSL *ssl = NULL;
@@ -2933,7 +3041,7 @@ EST_ERROR est_client_enroll (EST_CTX *ctx, char *cn, int *pkcs7_len,
     if (rv != EST_ERR_NONE) {
         goto err;
     }
-    rv = est_client_enroll_cn(ctx, ssl, cn, pkcs7_len, new_public_key);
+    rv = est_client_enroll_cn(ctx, ssl, cn, pkcs7_len, new_public_key, new_alt_public_key /*ISARA*/);
     est_client_disconnect(ctx, &ssl);
     if (rv == EST_ERR_AUTH_FAIL &&
         (ctx->auth_mode == AUTH_DIGEST ||
@@ -2957,7 +3065,7 @@ EST_ERROR est_client_enroll (EST_CTX *ctx, char *cn, int *pkcs7_len,
             EST_LOG_ERR("Connection failed on second attempt with basic/digest/token parameters");
             goto err;
         }
-        rv = est_client_enroll_cn(ctx, ssl, cn, pkcs7_len, new_public_key);
+        rv = est_client_enroll_cn(ctx, ssl, cn, pkcs7_len, new_public_key, new_alt_public_key /*ISARA*/);
         if (rv != EST_ERR_NONE) {
             EST_LOG_ERR("Enroll failed on second attempt during basic/digest authentication");
 
@@ -3002,6 +3110,11 @@ EST_ERROR est_client_enroll (EST_CTX *ctx, char *cn, int *pkcs7_len,
     client's key pair to be used in the simple enroll request .  The public
     key is included in the Certificate Signing Request (CSR) sent to the CA
     Server, and the private key is used to sign the request.
+    @param new_alt_public_key Pointer an EVP_PKEY structure that holds the
+    client's alternative key pair to be used in the simple enroll request.
+    The alternative public key is included in the Certificate Signing Request
+    (CSR) sent to the CA Server, and the alternative private key is used to sign
+    the request.
  
     @return EST_ERROR
 
@@ -3039,7 +3152,7 @@ EST_ERROR est_client_enroll (EST_CTX *ctx, char *cn, int *pkcs7_len,
 EST_ERROR est_client_provision_cert (EST_CTX *ctx, char *cn, 
 	                             int *pkcs7_len,
 				     int *ca_cert_len,
-                                     EVP_PKEY *new_public_key)
+                                     EVP_PKEY *new_public_key, EVP_PKEY *new_alt_public_key /*ISARA*/)
 {
     EST_ERROR rv;
     unsigned char *new_ta_p7;
@@ -3132,7 +3245,7 @@ EST_ERROR est_client_provision_cert (EST_CTX *ctx, char *cn,
      * Finally, we can attempt to enroll a new certificate using the
      * Common Name provided by the application.
      */
-    rv = est_client_enroll(ctx, cn, pkcs7_len, new_public_key);
+    rv = est_client_enroll(ctx, cn, pkcs7_len, new_public_key, new_alt_public_key /*ISARA*/);
 
     return (rv);
 }
@@ -3175,12 +3288,13 @@ EST_ERROR est_client_provision_cert (EST_CTX *ctx, char *cn,
     responsible for re-applying any X509 extensions that are to be issued with
     the renewed certificate.
  */
-EST_ERROR est_client_reenroll (EST_CTX *ctx, X509 *cert, int *pkcs7_len, EVP_PKEY *priv_key)
+EST_ERROR est_client_reenroll (EST_CTX *ctx, X509 *cert, int *pkcs7_len, EVP_PKEY *priv_key, EVP_PKEY *alt_priv_key /*ISARA*/)
 {
     X509_REQ *req;
     EST_ERROR rv;
     SSL *ssl = NULL;
     int ossl_rv;
+    EVP_PKEY *alt_pkey = NULL; /*ISARA */
 
     if (!ctx) {
         return (EST_ERR_NO_CTX);
@@ -3194,6 +3308,23 @@ EST_ERROR est_client_reenroll (EST_CTX *ctx, X509 *cert, int *pkcs7_len, EVP_PKE
         return (EST_ERR_NO_KEY);
     }
 
+    /* ISARA: BEGIN */
+    if (X509_get_ext_by_NID(cert, NID_subj_alt_pub_key, -1) >= 0) {
+        alt_pkey = est_client_cert_get_alt_pubkey(cert);
+        if (alt_pkey == NULL) {
+            EST_LOG_ERR("Failed to get alternative public key from cert");
+            return EST_ERR_X509_PUBKEY;
+        }
+    }
+    if (!alt_priv_key && alt_pkey) {
+        /* no alternate private key was provided, but the certificate contains
+         * an alt public key.  We can't do client auth without the alt private
+         * key. */
+        EST_LOG_ERR("Certificate contains alternative public key but no alternative private key was provided.");
+        return (EST_ERR_NO_KEY);
+    }
+    /* ISARA: END */
+
     if (!ctx->est_client_initialized) {
         return (EST_ERR_CLIENT_NOT_INITIALIZED);
     }
@@ -3214,6 +3345,22 @@ EST_ERROR est_client_reenroll (EST_CTX *ctx, X509 *cert, int *pkcs7_len, EVP_PKE
         return (EST_ERR_CLIENT_INVALID_KEY);
     }
 
+    /* ISARA: BEGIN */
+    /*
+     * Check the multiple public-key algoritm certificate given to us
+     */
+    if (alt_priv_key != NULL) {
+        rv = est_client_cert_check_alt_sig_sanity(cert);
+        if (rv != EST_ERR_NONE) {
+            return (rv);
+        }
+
+        if (X509_check_alt_private_key(cert, alt_priv_key) <= 0) {
+            return (EST_ERR_CLIENT_INVALID_KEY);
+        }
+    }
+    /* ISARA: END */
+
     /*
      * Convert the existing certificate to a CSR
      * This will copy the subject name from the cert into
@@ -3242,6 +3389,23 @@ EST_ERROR est_client_reenroll (EST_CTX *ctx, X509 *cert, int *pkcs7_len, EVP_PKE
 	}
     }
 
+    /* ISARA: BEGIN */
+    /* Remove the alternative extensions copied from the cert into the CSR */
+    rv = est_client_req_remove_copied_alt_extensions(req);
+    if (rv != EST_ERR_NONE) {
+        goto err;
+    }
+
+    /* Add the alt public key to the CSR */
+    if (alt_pkey) {
+        rv = est_client_csr_add_alt_pubkey(req, alt_pkey);
+        if (rv != EST_ERR_NONE) {
+            EST_LOG_ERR("Failed to copy alternative public key to CSR");
+            goto err;
+        }
+    }
+    /* ISARA: END */
+
     /*
      * Establish TLS session with the EST server
      */
@@ -3253,7 +3417,7 @@ EST_ERROR est_client_reenroll (EST_CTX *ctx, X509 *cert, int *pkcs7_len, EVP_PKE
     /*
      * Send the re-enroll request
      */
-    rv = est_client_enroll_pkcs10(ctx, ssl, req, pkcs7_len, priv_key, 1);
+    rv = est_client_enroll_pkcs10(ctx, ssl, req, pkcs7_len, priv_key, alt_priv_key /*ISARA*/, 1);
     est_client_disconnect(ctx, &ssl);
     if (rv == EST_ERR_AUTH_FAIL &&
         (ctx->auth_mode == AUTH_DIGEST ||
@@ -3277,7 +3441,7 @@ EST_ERROR est_client_reenroll (EST_CTX *ctx, X509 *cert, int *pkcs7_len, EVP_PKE
             EST_LOG_ERR("Connection failed on second attempt with basic/digest parameters");
             goto err;
         }
-        rv = est_client_enroll_pkcs10(ctx, ssl, req, pkcs7_len, priv_key, 1);
+        rv = est_client_enroll_pkcs10(ctx, ssl, req, pkcs7_len, priv_key, alt_priv_key /*ISARA*/, 1);
         if (rv != EST_ERR_NONE) {
             EST_LOG_ERR("Reenroll failed on second attempt during basic/digest authentication");
             
@@ -3302,6 +3466,11 @@ err:
         SSL_shutdown(ssl);
         SSL_free(ssl);
     }
+    /* ISARA: BEGIN */
+    if (alt_pkey) {
+        EVP_PKEY_free(alt_pkey);
+    }
+    /* ISARA: END */
     X509_REQ_free(req);
 
     return (rv);
@@ -3723,7 +3892,7 @@ EST_ERROR est_client_enable_srp (EST_CTX *ctx, int strength, char *uid, char *pw
     @return EST_ERROR.  If error, NULL.
 */
 EST_ERROR est_client_set_auth (EST_CTX *ctx, const char *uid, const char *pwd,
-                               X509 *client_cert, EVP_PKEY *private_key)
+                               X509 *client_cert, EVP_PKEY *private_key, EVP_PKEY *alt_private_key /* ISARA */)
 {
     EST_ERROR rv = EST_ERR_NONE;
     
@@ -3744,13 +3913,14 @@ EST_ERROR est_client_set_auth (EST_CTX *ctx, const char *uid, const char *pwd,
      * get them loaded into the SSL context so that they'll be used.
      */
     ctx->client_key = private_key;
+    ctx->alt_client_key = alt_private_key; /* ISARA */
     ctx->client_cert = client_cert;
     
     /*
      * Load the client cert if it's available
      */
     if (ctx->client_cert && ctx->client_key) {
-        if (est_client_set_cert_and_key(ctx->ssl_ctx, ctx->client_cert, ctx->client_key)) {
+        if (est_client_set_cert_and_key(ctx->ssl_ctx, ctx->client_cert, ctx->client_key, ctx->alt_client_key /* ISARA */)) {
             EST_LOG_ERR("Unable to load local certificate and private key");
             return EST_ERR_CLIENT_INVALID_KEY;
         }
diff --git a/src/est/est_client_alt.h b/src/est/est_client_alt.h
new file mode 100644
index 0000000..52ba8d2
--- /dev/null
+++ b/src/est/est_client_alt.h
@@ -0,0 +1,91 @@
+/** @file est_client_alt.h
+ *
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software plug-ins in source code or
+ * object code or both (the Software) and accompanying materials (the
+ * Documentation) that are subject to the license terms and restrictions
+ * described below (the License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (Isara) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and you refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) ZIP
+ * file, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an AS IS
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Daniel Van Geest, daniel.vangeest@isara.com, December,
+ * 2017.
+ */
+#ifndef HEADER_EST_CLIENT_ALT_H
+#define HEADER_EST_CLIENT_ALT_H
+
+#include "est.h"
+#include <openssl/ossl_typ.h>
+#include <openssl/x509v3.h>
+
+/*
+ * These prototypes are private to est_client.c and are
+ * not part of the public API.
+ */
+EST_ERROR est_client_req_alt_sign(X509_REQ *csr, EVP_PKEY *alt_pkey);
+EST_ERROR est_client_req_remove_copied_alt_extensions(X509_REQ *csr);
+EST_ERROR est_client_req_remove_alt_sig_attributes(X509_REQ *csr);
+EVP_PKEY *est_client_cert_get_alt_pubkey(X509 *cert);
+int est_client_cert_verify_alt_signature(X509_STORE_CTX *ctx);
+EST_ERROR est_client_cert_check_alt_sig_sanity(X509 *cert);
+
+#endif
\ No newline at end of file
diff --git a/src/est/est_client_alt_cert.c b/src/est/est_client_alt_cert.c
new file mode 100644
index 0000000..1b85d3d
--- /dev/null
+++ b/src/est/est_client_alt_cert.c
@@ -0,0 +1,393 @@
+/** @file est_client_alt_cert.c
+ *
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software plug-ins in source code or
+ * object code or both (the Software) and accompanying materials (the
+ * Documentation) that are subject to the license terms and restrictions
+ * described below (the License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (Isara) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and you refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) ZIP
+ * file, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an AS IS
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Daniel Van Geest, daniel.vangeest@isara.com, December,
+ * 2017.
+ */
+#include "est_client_alt.h"
+
+#include "est.h"
+#include "est_locl.h"
+#include "est_ossl_util.h"
+#include <openssl/asn1.h>
+#include <openssl/ossl_typ.h>
+#include <openssl/x509v3.h>
+
+EVP_PKEY *est_client_cert_get_alt_pubkey(X509 *cert)
+{
+    int alt_pub_key_ind = -1;
+    X509_EXTENSION *alt_pub_key_ext = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+    X509_PUBKEY *x509_pub_alt = NULL;
+    EVP_PKEY *alt_pubkey = NULL;
+
+    /* Find the issuer's ALT public key extension. */
+    alt_pub_key_ind = X509_get_ext_by_NID(cert, NID_subj_alt_pub_key, -1);
+    if (alt_pub_key_ind < 0) {
+        EST_LOG_ERR("Error finding the issuer's ALT public key extension");
+        goto end;
+    }
+
+    /* Get the issuer's ALT public key extension. */
+    alt_pub_key_ext = X509_get_ext(cert, alt_pub_key_ind);
+    if (alt_pub_key_ext == NULL) {
+        EST_LOG_ERR("Error getting the issuer's ALT public key extension");
+        goto end;
+    }
+
+    /* ASN.1 parse the ALT public key extension. */
+    sapki = X509V3_EXT_d2i(alt_pub_key_ext);
+    if (sapki == NULL) {
+        EST_LOG_ERR("Error converting the issuer's ALT public key extension into ASN.1");
+        goto end;
+    }
+
+    /* Convert the x509 formatted public key into a pkey */
+    x509_pub_alt = X509_PUBKEY_new();
+    if (x509_pub_alt == NULL) {
+        EST_LOG_ERR("Memory allocation error");
+        goto end;
+    }
+    X509_ALGOR_free(x509_pub_alt->algor);
+    ASN1_BIT_STRING_free(x509_pub_alt->public_key);
+
+    x509_pub_alt->algor = sapki->algor;
+    x509_pub_alt->public_key = sapki->public_key;
+    x509_pub_alt->pkey = NULL;
+
+    alt_pubkey = X509_PUBKEY_get(x509_pub_alt);
+
+    x509_pub_alt->algor = NULL;
+    x509_pub_alt->public_key = NULL;
+    X509_PUBKEY_free(x509_pub_alt);
+    x509_pub_alt = NULL;
+
+    if (alt_pubkey == NULL) {
+        EST_LOG_ERR("Error converting alt public key into a PKEY");
+        goto end;
+    }
+
+end:
+    if (sapki) {
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+    }
+
+    return alt_pubkey;
+}
+
+#define X509_NAME_LINE_LENGTH 128
+
+int est_client_cert_verify_alt_signature(X509_STORE_CTX *ctx)
+{
+    X509 *current_cert = X509_STORE_CTX_get_current_cert(ctx);
+    X509 *issuer_cert = NULL;
+    int cert_depth = X509_STORE_CTX_get_error_depth(ctx);
+    STACK_OF(X509) *chain = X509_STORE_CTX_get1_chain(ctx);
+    int alt_sigval_ind = -1;
+    X509_EXTENSION *alt_sigval_ext = NULL;
+    X509_EXTENSION *new_alt_sigval_ext = NULL;
+    EVP_PKEY *alt_pub_key = NULL;
+    X509_ALGOR *algo_holder = NULL;
+
+    int issuer_has_alt_pubkey = 0;
+    int subject_has_alt_sigval = 0;
+    int subject_has_alt_sigalg = 0;
+
+    int alt_sigalg_ind = -1;
+    X509_ALGOR *alt_sigalg = NULL;
+    X509_EXTENSION *alt_sigalg_ext = NULL;
+
+    int alg_nid = -1;
+    ASN1_BIT_STRING *alt_sigval = NULL;
+    ASN1_BIT_STRING *new_sig = NULL;
+    X509 * alt_free_cert = NULL;
+    char cert_name[X509_NAME_LINE_LENGTH] = { 0 };
+    char issuer_name[X509_NAME_LINE_LENGTH] = { 0 };
+    int ok = 0;
+
+    if (current_cert == NULL || chain == NULL) {
+        EST_LOG_ERR("Error getting chain or cert");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    if (sk_X509_num(chain) - 1 == cert_depth) {
+        /* Root cert, verify that it is self-signed */
+        issuer_cert = current_cert;
+    } else {
+        issuer_cert = sk_X509_value(chain, cert_depth + 1);
+        if (issuer_cert == NULL) {
+            EST_LOG_ERR("Error finding the issuer certificate");
+            ossl_dump_ssl_errors();
+            goto end;
+        }
+    }
+
+    issuer_has_alt_pubkey = X509_get_ext_by_NID(issuer_cert, NID_subj_alt_pub_key, -1) >= 0;
+    subject_has_alt_sigalg = X509_get_ext_by_NID(current_cert, NID_alt_sigalg, -1) >= 0;
+    subject_has_alt_sigval = X509_get_ext_by_NID(current_cert, NID_alt_sigval, -1) >= 0;
+
+    /* Check that the alt extensions, if they exist, are used in a valid combination */
+    if (issuer_has_alt_pubkey && !subject_has_alt_sigval) {
+        EST_LOG_ERR("Invalid subject cert, issuer has alt public key but subject doesn't have alt signature");
+        goto end;
+    } else if (!issuer_has_alt_pubkey && subject_has_alt_sigval) {
+        EST_LOG_ERR("Invalid subject cert, issuer doesn't have alt public key but subject has alt signature");
+        goto end;
+    } else if (subject_has_alt_sigval != subject_has_alt_sigalg) {
+        EST_LOG_ERR("Invalid subject cert, has alt sig alg=%d, has alt sig val=%d", subject_has_alt_sigalg, subject_has_alt_sigval);
+        goto end;
+    }
+
+    /* The alt extensions are consistent, so if there's no alt signature then there's noting to verify and it's all good. */
+    if (!subject_has_alt_sigval) {
+        ok = 1;
+        goto end;
+    }
+
+    /* Find the issuer's ALT public key extension. */
+    alt_pub_key = est_client_cert_get_alt_pubkey(issuer_cert);
+    if (alt_pub_key == NULL) {
+        EST_LOG_ERR("Error getting alt public key from cert");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    /* Find the ALT signature value extensions and convert it to an ASN.1 thing. */
+    alt_sigalg_ind = X509_get_ext_by_NID(current_cert, NID_alt_sigalg, -1);
+    if (alt_sigalg_ind < 0) {
+        EST_LOG_ERR("Error finding the certificate's ALT signature algorithm extension");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    alt_sigalg_ext = X509_get_ext(current_cert, alt_sigalg_ind);
+    if (alt_sigalg_ext == NULL) {
+        EST_LOG_ERR("Error getting the certificate's ALT signature algorithm extension.");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    alt_sigalg = X509V3_EXT_d2i(alt_sigalg_ext);
+    if (alt_sigalg == NULL) {
+        EST_LOG_ERR("Error converting the issuer's ALT signature algorithm extension into ASN.1.");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    /* Find the ALT signature value extension and convert it to an ASN.1 thing. */
+    alt_sigval_ind = X509_get_ext_by_NID(current_cert, NID_alt_sigval, -1);
+    if (alt_sigval_ind < 0) {
+        EST_LOG_ERR("Error finding the certificate's ALT signature extension");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    alt_sigval_ext = X509_get_ext(current_cert, alt_sigval_ind);
+    if (alt_sigval_ext == NULL) {
+        EST_LOG_ERR("Error getting the certificate's ALT signature extension");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    alt_sigval = X509V3_EXT_d2i(alt_sigval_ext);
+    if (alt_sigval == NULL) {
+        EST_LOG_ERR("Error converting the issuer's ALT signature extension into ASN.1");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    /* Ensure that the signature algorithm specified in the signature algorithm extension
+     * and the algorithm of the issuer's public key matches.
+     */
+    if (OBJ_find_sigid_algs(OBJ_obj2nid(alt_sigalg->algorithm), NULL, &alg_nid) == 0) {
+        EST_LOG_ERR("Couldn't get the algorithm ID from the ALT signature.");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    if (alg_nid != alt_pub_key->type) {
+        EST_LOG_ERR("Issuer public key algorithm does not match signature algorithm.");
+        goto end;
+    }
+
+    new_sig = ASN1_OCTET_STRING_dup(alt_sigval);
+    if (new_sig == NULL) {
+        EST_LOG_ERR("Error duplicating the ALT signature");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    /* Now duplicate the current certificate, remove the ALT signature extension
+     * and verify against that. We hid the classical algorithm during the signing
+     * process so we also have to do it again to verify against the same thing.
+     */
+    alt_free_cert = X509_dup(current_cert);
+    if (alt_free_cert == NULL) {
+        EST_LOG_ERR("Error duplicating the certificate");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    alt_sigval_ind = X509_get_ext_by_NID(alt_free_cert, NID_alt_sigval, -1);
+    if (alt_sigval_ind < 0) {
+        EST_LOG_ERR("Error getting the ALT signature extension");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    new_alt_sigval_ext = X509_get_ext(alt_free_cert, alt_sigval_ind);
+    if (new_alt_sigval_ext == NULL) {
+        EST_LOG_ERR("Error getting duplicate ALT signature extension to deallocate it");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    if (X509_delete_ext(alt_free_cert, alt_sigval_ind) == NULL) {
+        EST_LOG_ERR("Error removing the ALT signature extension");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    algo_holder = alt_free_cert->cert_info->signature;
+    alt_free_cert->cert_info->signature = NULL;
+
+    /* Stuff is being cached.  See https://www.openssl.org/docs/man1.1.0/crypto/X509_sign.html.
+     */
+    alt_free_cert->cert_info->enc.modified = 1;
+
+    if (ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF), alt_sigalg,
+                         new_sig, alt_free_cert->cert_info, alt_pub_key) <= 0) {
+        EST_LOG_ERR("Alt signature verification FAILED!");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    ok = 1;
+
+end:
+    EST_LOG_INFO("cert=%s, issuer=%s: %s",
+        X509_NAME_oneline(X509_get_subject_name(current_cert), cert_name, X509_NAME_LINE_LENGTH),
+        X509_NAME_oneline(X509_get_subject_name(issuer_cert), issuer_name, X509_NAME_LINE_LENGTH),
+        ok == 1 ? "ok" : "not ok");
+
+    if (chain) {
+        sk_X509_pop_free(chain, X509_free);
+    }
+    if (alt_sigalg) {
+        X509_ALGOR_free(alt_sigalg);
+    }
+    if (alt_free_cert) {
+        X509_free(alt_free_cert);
+    }
+    if (alt_pub_key) {
+        EVP_PKEY_free(alt_pub_key);
+    }
+    if (new_sig) {
+        ASN1_BIT_STRING_free(new_sig);
+    }
+    if (alt_sigval) {
+        ASN1_BIT_STRING_free(alt_sigval);
+    }
+    if (new_alt_sigval_ext) {
+        X509_EXTENSION_free(new_alt_sigval_ext);
+    }
+    if (algo_holder) {
+        X509_ALGOR_free(algo_holder);
+    }
+
+    return (ok);
+}
+
+/*
+ * This function does a sanity check on the Alternative
+ * extensions of the X509 prior to attempting to
+ * convert the X509 to a CSR for a reenroll
+ * operation.
+ *
+ * Returns an EST_ERROR code
+ */
+EST_ERROR est_client_cert_check_alt_sig_sanity (X509 *cert)
+{
+    int idx = 0;
+
+    idx = X509_get_ext_by_NID(cert, NID_alt_sigval, -1);
+    if (idx < 0) {
+        EST_LOG_ERR("The certificate provided does not contain an ALT signature.");
+        return (EST_ERR_BAD_X509);
+    }
+
+    idx = X509_get_ext_by_NID(cert, NID_alt_sigalg, -1);
+    if (idx < 0) {
+        EST_LOG_ERR("The certificate provided does not contain an ALT signature algorithm.");
+        return (EST_ERR_BAD_X509);
+    }
+
+    return (EST_ERR_NONE);
+}
diff --git a/src/est/est_client_alt_csr.c b/src/est/est_client_alt_csr.c
new file mode 100644
index 0000000..56a4cb7
--- /dev/null
+++ b/src/est/est_client_alt_csr.c
@@ -0,0 +1,523 @@
+/** @file est_client_csr.c
+ *
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software plug-ins in source code or
+ * object code or both (the Software) and accompanying materials (the
+ * Documentation) that are subject to the license terms and restrictions
+ * described below (the License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (Isara) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and you refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) ZIP
+ * file, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an AS IS
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Daniel Van Geest, daniel.vangeest@isara.com, December,
+ * 2017.
+ */
+#include "est_client_alt.h"
+
+#include "est.h"
+#include "est_locl.h"
+#include "est_ossl_util.h"
+#include <openssl/asn1.h>
+#include <openssl/ossl_typ.h>
+#include <openssl/x509v3.h>
+
+/*
+ * Create Subject Alt Public Key Info attribute for addition to a CSR.
+ */
+static X509_ATTRIBUTE *create_SAPKI_ATTRIBUTE(SUBJECT_ALT_PUBLIC_KEY_INFO *sapki) {
+    unsigned char *p = NULL;
+    unsigned char *data = NULL;
+    ASN1_STRING *seq = NULL;
+    int i = 0;
+    int total = 0;
+    X509_ATTRIBUTE *attr = NULL;
+
+    i = i2d_SUBJECT_ALT_PUBLIC_KEY_INFO(sapki, NULL);
+    if (i < 0) {
+        EST_LOG_ERR("Failed to get ASN.1 size of SAPKI attribute.");
+        goto end;
+    }
+
+    total = ASN1_object_size(1,i,V_ASN1_SEQUENCE);
+
+    data = OPENSSL_malloc(total);
+    if (data == NULL) {
+        EST_LOG_ERR("Memory failure during SAPKI attribute creation.");
+        goto end;
+    }
+
+    p=data;
+    ASN1_put_object(&p, 1, i, V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);
+    i = i2d_SUBJECT_ALT_PUBLIC_KEY_INFO(sapki, &p);
+    if (i < 0) {
+        EST_LOG_ERR("Failed to ASN.1 encode the SAPKI attribute.");
+        goto end;
+    }
+
+    seq = ASN1_STRING_new();
+    if (!ASN1_STRING_set(seq, data, total)) {
+        EST_LOG_ERR("Failed to alloc/set string for SAPKI attribute.");
+        ASN1_STRING_free(seq);
+        goto end;
+    }
+
+    attr = X509_ATTRIBUTE_create(NID_subj_alt_pub_key, V_ASN1_SEQUENCE, seq);
+    if (attr == NULL) {
+        EST_LOG_ERR("Failed to create the SAPKI attribute.");
+        goto end;
+    }
+
+end:
+    OPENSSL_free(data);
+    return attr;
+}
+
+/*
+ * Create Alt Signature Value attribute for addition to a CSR.
+ */
+static X509_ATTRIBUTE *create_ALTSIG_ATTRIBUTE(ASN1_BIT_STRING *altsig) {
+    X509_ATTRIBUTE *attr = NULL;
+
+    attr = X509_ATTRIBUTE_create(NID_alt_sigval, V_ASN1_BIT_STRING, altsig);
+    if (attr == NULL) {
+        EST_LOG_ERR("Failed to create the ALTSIG attribute.");
+        goto end;
+    }
+
+end:
+    return attr;
+}
+
+/*
+ * Create Alt Signature Algorithm attribute for addition to a CSR.
+ */
+static X509_ATTRIBUTE *create_ALTSIGALG_ATTRIBUTE(X509_ALGOR *altsigalg) {
+    X509_ATTRIBUTE *attr = NULL;
+    unsigned char *p = NULL;
+    unsigned char *data = NULL;
+    ASN1_STRING *astr = NULL;
+    int i = 0;
+
+    i = i2d_X509_ALGOR(altsigalg, NULL);
+    if (i < 0) {
+        EST_LOG_ERR("Failed to get ASN.1 size of ALTSIGALG attribute.");
+        goto end;
+    }
+
+    data = OPENSSL_malloc(i);
+    if (data == NULL) {
+        EST_LOG_ERR("Memory failure during ALTSIGALG attribute creation.");
+        goto end;
+    }
+
+    p=data;
+    i = i2d_X509_ALGOR(altsigalg, &p);
+    if (i < 0) {
+        EST_LOG_ERR("Failed to ASN.1 encode the ALTSIGALG attribute.");
+        goto end;
+    }
+
+    astr = ASN1_STRING_new();
+    if (!ASN1_STRING_set(astr, data, i)) {
+        EST_LOG_ERR("Failed to alloc/set string for ALTSIGALG attribute.");
+        ASN1_STRING_free(astr);
+        goto end;
+    }
+
+    attr = X509_ATTRIBUTE_create(NID_alt_sigalg, V_ASN1_SEQUENCE, astr);
+    if (attr == NULL) {
+        ASN1_STRING_free(astr);
+        EST_LOG_ERR("Failed to create the ALTSIGALG attribute.");
+        goto end;
+    }
+
+end:
+    OPENSSL_free(data);
+    return attr;
+}
+
+/*
+ * Add the Alt Signature Algorithm attribure to a CSR.
+ */
+static EST_ERROR req_add_alt_sig_algor (X509_REQ *csr, EVP_PKEY *alt_priv_key)
+{
+    EST_ERROR rv = EST_ERR_NONE;
+    X509_PUBKEY *x509_sig_alt = NULL;
+    X509_ALGOR *altsig_algor = NULL;
+    int snid = -1;
+    X509_ATTRIBUTE *attr_altsigalg = NULL;
+
+    X509_PUBKEY_set(&x509_sig_alt, alt_priv_key);
+
+    altsig_algor = X509_ALGOR_dup(x509_sig_alt->algor);
+    if (altsig_algor == NULL) {
+        EST_LOG_ERR("Error duplicating public key algor");
+        rv = EST_ERR_MALLOC;
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    /* Make sure that the right digest is set. */
+    if (!OBJ_find_sigid_by_algs(&snid, NID_sha512, EVP_PKEY_id(alt_priv_key))) {
+        EST_LOG_ERR("Error getting NID for digest/signature algorithm combination");
+        rv = EST_ERR_X509_ATTR;
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    if (X509_ALGOR_set0(altsig_algor, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0) == 0) {
+        EST_LOG_ERR("Error setting algorithm object ID");
+        rv = EST_ERR_X509_ATTR;
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    attr_altsigalg = create_ALTSIGALG_ATTRIBUTE(altsig_algor);
+
+    /* Add the ALT signature algorithm extension so the signing process includes it.
+     */
+    if (X509_REQ_add1_attr(csr, attr_altsigalg) == 0) {
+        EST_LOG_ERR("Error adding signature algorithm as extension");
+        rv = EST_ERR_X509_ATTR;
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    csr->req_info->enc.modified = 1;
+
+end:
+    if (attr_altsigalg) {
+        X509_ATTRIBUTE_free(attr_altsigalg);
+    }
+    if (altsig_algor) {
+        X509_ALGOR_free(altsig_algor);
+    }
+    if (x509_sig_alt) {
+        X509_PUBKEY_free(x509_sig_alt);
+    }
+
+    return rv;
+}
+
+/*
+ * Sign the CSR with the Alt private key and add the Alt Signature Value
+ * attribute to the CSR.
+ */
+static EST_ERROR req_alt_key_sign (X509_REQ *csr, EVP_PKEY *alt_priv_key)
+{
+    EST_ERROR rv = EST_ERR_NONE;
+    X509_PUBKEY *x509_sig_alt = NULL;
+
+    EVP_MD_CTX mctx;
+    EVP_MD_CTX_init(&mctx);
+    const EVP_MD *md_alg = EVP_sha512();
+
+    unsigned char *sign_in = NULL;
+    size_t sign_in_size = 0;
+    unsigned char *sign_out = NULL;
+    size_t sign_out_size = 0;
+
+    ASN1_BIT_STRING *alt_sigval_as_asn1bitstring = NULL;
+    X509_ATTRIBUTE *attr_altsig = NULL;
+
+    X509_PUBKEY_set(&x509_sig_alt, alt_priv_key);
+
+    /* Sign the req with the alt private key. */
+    if (EVP_DigestSignInit(&mctx, NULL, md_alg, NULL, alt_priv_key) < 1) {
+        EST_LOG_ERR("Error doing EVP digest initialization");
+        rv = EST_ERR_X509_SIGN;
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    sign_in_size = ASN1_item_i2d((ASN1_VALUE *)csr->req_info, &sign_in, ASN1_ITEM_rptr(X509_REQ_INFO));
+
+    sign_out_size = EVP_PKEY_size(alt_priv_key);
+    sign_out = OPENSSL_malloc(sign_out_size);
+    if ((sign_in == NULL) || (sign_out == NULL)) {
+        EST_LOG_ERR("Memory allocation error for signing input or output");
+        rv = EST_ERR_MALLOC;
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    if (!EVP_DigestSignUpdate(&mctx, sign_in, sign_in_size)
+        || !EVP_DigestSignFinal(&mctx, sign_out, &sign_out_size)) {
+        EST_LOG_ERR("EVP digest/sign operation error. Did you run out of HSS one-time-keys?");
+        rv = EST_ERR_X509_SIGN;
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    /* Prepare an ASN1 bit string for the alt signature extension. */
+    alt_sigval_as_asn1bitstring = ASN1_BIT_STRING_new();
+    if (alt_sigval_as_asn1bitstring == NULL) {
+        EST_LOG_ERR("ASN1 bit string memory allocation error");
+        rv = EST_ERR_MALLOC;
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    alt_sigval_as_asn1bitstring->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
+    alt_sigval_as_asn1bitstring->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+    alt_sigval_as_asn1bitstring->data = sign_out;
+    alt_sigval_as_asn1bitstring->length = sign_out_size;
+
+    /* Prevent a double free. */
+    sign_out = NULL;
+    sign_out_size = 0;
+
+    attr_altsig = create_ALTSIG_ATTRIBUTE(alt_sigval_as_asn1bitstring);
+    if (attr_altsig == NULL) {
+        EST_LOG_ERR("Error creating signature extension");
+        goto end;
+    }
+    alt_sigval_as_asn1bitstring = NULL;
+
+    if (X509_REQ_add1_attr(csr, attr_altsig) == 0) {
+        EST_LOG_ERR("Error adding signature as extension");
+        goto end;
+    }
+
+    csr->req_info->enc.modified = 1;
+
+end:
+    if (attr_altsig) {
+        X509_ATTRIBUTE_free(attr_altsig);
+    }
+    OPENSSL_free(sign_out);
+    OPENSSL_free(sign_in);
+    if (alt_sigval_as_asn1bitstring) {
+        ASN1_BIT_STRING_free(alt_sigval_as_asn1bitstring);
+    }
+    if (x509_sig_alt) {
+        X509_PUBKEY_free(x509_sig_alt);
+    }
+    EVP_MD_CTX_cleanup(&mctx);
+
+    return rv;
+}
+
+/*
+ * Adds the Alt Signature Algorithm and properly computed Alt Signature Value
+ * attributes to the CSR.
+ */
+EST_ERROR est_client_req_alt_sign (X509_REQ *csr, EVP_PKEY *alt_pkey)
+{
+	EST_ERROR rv = EST_ERR_NONE;
+
+    rv = req_add_alt_sig_algor(csr, alt_pkey);
+    if (rv != EST_ERR_NONE) {
+        EST_LOG_ERR("Unable to add alterantive signature algorithm to certificate request");
+        return rv;
+    }
+
+    rv = req_alt_key_sign(csr, alt_pkey);
+    if (rv != EST_ERR_NONE) {
+        EST_LOG_ERR("Unable to create multiple public-key algorithm certificate request");
+        return rv;
+    }
+
+    return rv;
+}
+
+/*
+ * The Alt SPKI, Signature Value and Signature Algorithm extensions may have
+ * been copied from a cert into a new CSR when creating the CSR from an
+ * existing cert while re-registering.  Remove these extensions from the CSR
+ * the appropriate alt values will be added as attributes to the CSR later.
+ */
+EST_ERROR est_client_req_remove_copied_alt_extensions (X509_REQ *csr)
+{
+    int idx = 0;
+    int ossl_rv = 0;
+    STACK_OF(X509_EXTENSION) *exts = NULL;
+
+    exts = X509_REQ_get_extensions(csr);
+    if (exts != NULL) {
+        idx = X509v3_get_ext_by_NID(exts, NID_subj_alt_pub_key, -1);
+        if (idx >= 0) {
+            if (X509v3_delete_ext(exts, idx) == NULL) {
+                EST_LOG_ERR("Failed to delete Subject-Alt-Public-Key REQ extension.");
+                return EST_ERR_X509_ATTR;
+            }
+        }
+
+        idx = X509v3_get_ext_by_NID(exts, NID_alt_sigval, -1);
+        if (idx >= 0) {
+            if (X509v3_delete_ext(exts, idx) == NULL) {
+                EST_LOG_ERR("Failed to delete Alt-Signature-Value REQ extension.");
+                return EST_ERR_X509_ATTR;
+            }
+        }
+
+        idx = X509v3_get_ext_by_NID(exts, NID_alt_sigalg, -1);
+        if (idx >= 0) {
+            if (X509v3_delete_ext(exts, idx) == NULL) {
+                EST_LOG_ERR("Failed to delete Alt-Signature-Algorithm REQ extension.");
+                return EST_ERR_X509_ATTR;
+            }
+        }
+
+        idx = X509_REQ_get_attr_by_NID(csr, NID_ext_req, -1);
+        if (idx < 0) {
+            EST_LOG_ERR("Failed find REQ extensions.");
+            return EST_ERR_X509_ATTR;
+        }
+
+        if (X509_REQ_delete_attr(csr, idx) == NULL) {
+            EST_LOG_ERR("Failed to delete REQ extensions.");
+            return EST_ERR_X509_ATTR;
+        }
+
+        ossl_rv = X509_REQ_add_extensions(csr, exts);
+        if (!ossl_rv) {
+            EST_LOG_ERR("Failed to re-add REQ extensions.");
+            return EST_ERR_X509_ATTR;
+        }
+    }
+
+    return EST_ERR_NONE;
+}
+
+/*
+ * Add an alternative public key to the CSR.
+ */
+EST_ERROR est_client_csr_add_alt_pubkey (X509_REQ *csr, EVP_PKEY *alt_pub_key)
+{
+    EST_ERROR rv = EST_ERR_NONE;
+    X509_PUBKEY *x509_pub_alt = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+    X509_ATTRIBUTE *attr_sapki = NULL;
+
+    X509_PUBKEY_set(&x509_pub_alt, alt_pub_key);
+
+    sapki = SUBJECT_ALT_PUBLIC_KEY_INFO_new();
+    if (sapki == NULL) {
+        EST_LOG_ERR("Error allocating x509 pubkey");
+        rv = EST_ERR_MALLOC;
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    X509_ALGOR_free(sapki->algor);
+    ASN1_BIT_STRING_free(sapki->public_key);
+
+    sapki->algor = x509_pub_alt->algor;
+    sapki->public_key = x509_pub_alt->public_key;
+
+    attr_sapki = create_SAPKI_ATTRIBUTE(sapki);
+    sapki->algor = NULL;
+    sapki->public_key = NULL;
+    if (attr_sapki == NULL) {
+        EST_LOG_ERR("Error converting x509 alt pubkey to attribute.");
+        rv = EST_ERR_X509_PUBKEY;
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    if (X509_REQ_add1_attr(csr, attr_sapki) == 0) {
+        EST_LOG_ERR("Error adding alt public key attribute.");
+        goto end;
+    }
+
+end:
+    if (x509_pub_alt) {
+        X509_PUBKEY_free(x509_pub_alt);
+    }
+    if (sapki) {
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+    }
+    if (attr_sapki) {
+        X509_ATTRIBUTE_free(attr_sapki);
+    }
+
+    return rv;
+}
+
+/*
+ * This function is used to clear any Alt Signature
+ * attributes in an X509 CSR.  This is used because the
+ * contents of the CSR may have changed, so the Alt
+ * Signature needs to be regenerated.
+ */
+EST_ERROR est_client_req_remove_alt_sig_attributes (X509_REQ *csr)
+{
+    int idx = 0;
+
+    idx = X509_REQ_get_attr_by_NID(csr, NID_alt_sigalg, -1);
+    if (idx >= 0) {
+        if (X509_REQ_delete_attr(csr, idx) == NULL) {
+            EST_LOG_ERR("Failed delete Alt Signature Algorithm attribute.");
+            return EST_ERR_X509_ATTR;
+        }
+    }
+
+    idx = X509_REQ_get_attr_by_NID(csr, NID_alt_sigval, -1);
+    if (idx >= 0) {
+        if (X509_REQ_delete_attr(csr, idx) == NULL) {
+            EST_LOG_ERR("Failed delete Alt Signature Value attribute.");
+            return EST_ERR_X509_ATTR;
+        }
+    }
+
+    return EST_ERR_NONE;
+}
diff --git a/src/est/est_locl.h b/src/est/est_locl.h
index 63cca4f..2ac0fc6 100644
--- a/src/est/est_locl.h
+++ b/src/est/est_locl.h
@@ -35,18 +35,35 @@
  * Version identifiers.  These should be updated appropriately
  * for each release.
  */
+/* ISARA: BEGIN */
+/*
 #define EST_API_LEVEL       4  //Update this whenever there's a change to the public API
+*/
+#define EST_API_LEVEL       5  //Update this whenever there's a change to the public API
+/* ISARA: END */
 #define EST_VER_STRING      PACKAGE_STRING
 
 #define EST_URI_PATH_PREFIX_MAX_LEN (16)
 /* one segment for the possible CA path seg and one for the operation path */
 #define EST_URI_MAX_LEN     (EST_URI_PATH_PREFIX_MAX_LEN+EST_MAX_PATH_SEGMENT_LEN+EST_MAX_PATH_SEGMENT_LEN)
+/* ISARA: BEGIN */
+/*
 #define EST_BODY_MAX_LEN    16384
+*/
+/* ISARA: END */
 #define EST_CA_MAX	    2000000
 #define EST_TLS_UID_LEN     17
+/* ISARA: BEGIN */
+/*
 #define EST_RAW_CSR_LEN_MAX 8192
 
 #define EST_MAX_CONTENT_LEN 8192
+*/
+/* Dual-key CSRs and certificates are large, so increase maximum sizes */
+#define EST_RAW_CSR_LEN_MAX 262144
+
+#define EST_MAX_CONTENT_LEN 262144
+/* ISARA: END*/
 
 /* The retry-after values below are in seconds */
 #define EST_RETRY_PERIOD_DEF	3600 
@@ -57,7 +74,13 @@
 /*
  * Cipher suite filter for OpenSSL
  */
+/* ISARA: BEGIN */
+/*
 #define EST_CIPHER_LIST             "ALL:!aNULL:!eNULL:!SSLv2:!EXPORT:!SRP"
+*/
+/* For demo purposes, make the alt public-key algorithm authentication ciphersuite highest priority */
+#define EST_CIPHER_LIST             "ECDHE-HSS-AES256-GCM-SHA384:ALL:!aNULL:!eNULL:!SSLv2:!EXPORT:!SRP"
+/* ISARA: END */
 #define EST_CIPHER_LIST_SRP_SERVER  "ALL:!eNULL:!SSLv2:!EXPORT:SRP"
 #define EST_CIPHER_LIST_SRP_ONLY    "SRP:!aRSA:!aDSS"
 #define EST_CIPHER_LIST_SRP_AUTH    "SRP"
@@ -108,7 +131,13 @@
 
 #define EST_HTTP_HDR_EST_CLIENT     "LibEST client 1.0"
 
+/* ISARA: BEGIN */
+/*
 #define EST_HTTP_REQ_DATA_MAX       4096
+*/
+/* Max request data should be at least as big as the content we're sending... */
+#define EST_HTTP_REQ_DATA_MAX       EST_MAX_CONTENT_LEN
+/* ISARA: END */
 #define EST_HTTP_REQ_TERMINATOR_LEN 5
 #define EST_HTTP_REQ_TOTAL_LEN      EST_HTTP_HDR_MAX+EST_HTTP_REQ_DATA_MAX+EST_HTTP_REQ_TERMINATOR_LEN
 
@@ -236,6 +265,7 @@ struct est_ctx {
     char *uri_path_segment;
     X509 *client_cert;
     EVP_PKEY   *client_key;
+    EVP_PKEY   *alt_client_key; /* ISARA */
     EST_HTTP_AUTH_CRED_RC (*auth_credentials_cb)(EST_HTTP_AUTH_HDR *auth_credentials);
     EST_HTTP_AUTH_MODE auth_mode;
     char userid[MAX_UIDPWD+1];
@@ -291,6 +321,9 @@ struct est_ctx {
 
     int last_http_status;
     int enforce_csrattrs; /* Used to force the client to provide the CSR attrs in the CSR */
+    /* ISARA: BEGIN */
+    EVP_PKEY *server_alt_priv_key;
+    /* ISARA: END */
 };
 
 #define EST_MAX_ATTR_LEN    128 
@@ -306,7 +339,7 @@ typedef struct est_oid_list {
 /*
  * Index used to link the EST Ctx into the SSL structures
  */
-int e_ctx_ssl_exdata_index;
+//int e_ctx_ssl_exdata_index;
 
 
 LIBEST_TEST_API void est_log (EST_LOG_LEVEL lvl, char *format, ...);
@@ -396,7 +429,7 @@ int est_client_send_enroll_request(EST_CTX *ctx, SSL *ssl, BUF_MEM *bptr,
                                    unsigned char *pkcs7, int *pkcs7_len,
 				   int reenroll);
 LIBEST_TEST_API void est_client_disconnect(EST_CTX *ctx, SSL **ssl);
-LIBEST_TEST_API int est_client_set_cert_and_key(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key);
+LIBEST_TEST_API int est_client_set_cert_and_key(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key, EVP_PKEY *alt_key /* ISARA */);
 EST_ERROR est_client_set_uid_pw(EST_CTX *ctx, const char *uid, const char *pwd);
 
 /* From est_client_http.c */
diff --git a/src/est/est_proxy.c b/src/est/est_proxy.c
index dafa77b..6deccec 100644
--- a/src/est/est_proxy.c
+++ b/src/est/est_proxy.c
@@ -130,7 +130,7 @@ static EST_CTX *get_client_ctx (EST_CTX *p_ctx)
          * change the name in context to hold these.
          */
         rv = est_client_set_auth(c_ctx, p_ctx->userid, p_ctx->password,
-                                 p_ctx->server_cert, p_ctx->server_priv_key);
+                                 p_ctx->server_cert, p_ctx->server_priv_key, NULL /*ISARA*/);
         if (rv != EST_ERR_NONE) {
             EST_LOG_ERR("Unable to set authentication configuration in the client context for Proxy use");
 	    est_destroy(c_ctx);
diff --git a/src/est/est_server.c b/src/est/est_server.c
index da0b309..3449013 100644
--- a/src/est/est_server.c
+++ b/src/est/est_server.c
@@ -21,10 +21,12 @@
 #endif
 #include "est.h"
 #include "est_server_http.h"
+#include "est_server_alt.h" /* ISARA */
 #include "est_locl.h"
 #include "est_ossl_util.h"
 #include "safe_mem_lib.h"
 #include "safe_str_lib.h"
+#include <openssl/asn1_mac.h> /* ISARA */
 #include <openssl/x509.h>
 #include <openssl/x509v3.h>
 
@@ -1127,6 +1129,17 @@ static EST_ERROR est_handle_simple_enroll (EST_CTX *ctx, void *http_ctx, SSL *ss
 	return (EST_ERR_BAD_PKCS10);
     }
 
+    /* ISARA: BEGIN */
+    /*
+     * Perform a sanity check on the CSR
+     */
+    if (est_server_req_check_alt_csr(csr)) {
+        EST_LOG_ERR("PKCS10 CSR sent by the client failed alt public-key algoritm sanity check");
+        X509_REQ_free(csr);
+        return (EST_ERR_BAD_PKCS10);
+    }
+    /* ISARA: END */
+
     /*
      * Get the peer certificate if available.  This
      * identifies the client. The CA may desire
@@ -1656,7 +1669,7 @@ EST_CTX * est_server_init (unsigned char *ca_chain, int ca_chain_len,
                            unsigned char *cacerts_resp_chain, int cacerts_resp_chain_len,
 			   EST_CERT_FORMAT cert_format,
                            char *http_realm, 
-			   X509 *tls_id_cert, EVP_PKEY *tls_id_key)
+			   X509 *tls_id_cert, EVP_PKEY *tls_id_key, EVP_PKEY *tls_id_alt_key /*ISARA*/)
 {
     EST_CTX *ctx;
     int len;
@@ -1740,6 +1753,9 @@ EST_CTX * est_server_init (unsigned char *ca_chain, int ca_chain_len,
     strncpy_s(ctx->realm, MAX_REALM, http_realm, MAX_REALM);
     ctx->server_cert = tls_id_cert;
     ctx->server_priv_key = tls_id_key;
+    /* ISARA: BEGIN */
+    ctx->server_alt_priv_key = tls_id_alt_key;
+    /* ISARA: END */
     ctx->auth_mode = AUTH_BASIC;
     ctx->server_enable_pop = 1;
     ctx->local_cacerts_processing = 1;
diff --git a/src/est/est_server_alt.c b/src/est/est_server_alt.c
new file mode 100644
index 0000000..d998d82
--- /dev/null
+++ b/src/est/est_server_alt.c
@@ -0,0 +1,685 @@
+/** @file est_server_alt.c
+ *
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software plug-ins in source code or
+ * object code or both (the Software) and accompanying materials (the
+ * Documentation) that are subject to the license terms and restrictions
+ * described below (the License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (Isara) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and you refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) ZIP
+ * file, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an AS IS
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Daniel Van Geest, daniel.vangeest@isara.com, December,
+ * 2017.
+ */
+#include "est_server_alt.h"
+
+#include "est.h"
+#include "est_locl.h"
+#include "est_ossl_util.h"
+#include <openssl/asn1.h>
+#include <openssl/asn1_mac.h>
+#include <openssl/ossl_typ.h>
+#include <openssl/x509v3.h>
+
+/*
+ * Convert an X509 attribute to a SubjectAltPublicKeyInfo object.
+ */
+static SUBJECT_ALT_PUBLIC_KEY_INFO *get_SAPKI_from_ATTRIBUTE(X509_ATTRIBUTE *attr)
+{
+    ASN1_TYPE *so = NULL;
+    ASN1_OBJECT *o = OBJ_nid2obj(NID_subj_alt_pub_key);
+    ASN1_const_CTX c;
+    ASN1_STRING *s = NULL;
+    long length = 0;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+
+    if (OBJ_cmp(attr->object, o) != 0) {
+        fprintf (stderr, "Unexpected Object ID\n") ;
+        goto err;
+    }
+
+    if (!attr->single && sk_ASN1_TYPE_num(attr->value.set)) {
+        so = sk_ASN1_TYPE_value(attr->value.set, 0);
+    } else {
+        fprintf (stderr, "Attribute format error.\n") ;
+        goto err;
+    }
+
+    if ((so == NULL) || (so->type != V_ASN1_SEQUENCE)) {
+        fprintf (stderr, "Attribute ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    s = so->value.sequence;
+    c.p = ASN1_STRING_data(s);
+    length = ASN1_STRING_length(s);
+    c.max = c.p + length;
+    if (!asn1_GetSequence(&c, &length)) {
+        fprintf (stderr, "Attribute internal ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    c.q = c.p;
+    sapki = d2i_SUBJECT_ALT_PUBLIC_KEY_INFO(NULL, &c.p, c.slen);
+    if (sapki == NULL) {
+        fprintf (stderr, "Invalid ALT public key attribute.\n") ;
+        goto err;
+    }
+    c.slen -= (c.p - c.q);
+    c.q = c.p;
+
+    if (!asn1_const_Finish(&c)) {
+        fprintf (stderr, "Attribute had junk after the ASN.1 data.\n") ;
+        goto err;
+    }
+
+    return sapki;
+
+err:
+    SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+    return NULL;
+}
+
+/*
+ * Convert an X509 attribute to a Alt Signature Value BIT STRING.
+ */
+static ASN1_BIT_STRING *get_ALTSIGVAL_from_ATTRIBUTE(X509_ATTRIBUTE *attr) {
+
+    ASN1_TYPE *so = NULL;
+    ASN1_OBJECT *o = OBJ_nid2obj(NID_alt_sigval);
+    ASN1_BIT_STRING *altsig = NULL;
+
+    if (OBJ_cmp(attr->object, o) != 0) {
+        fprintf (stderr, "Unexpected Object ID\n") ;
+        goto err;
+    }
+
+    if (!attr->single && sk_ASN1_TYPE_num(attr->value.set)) {
+        so = sk_ASN1_TYPE_value(attr->value.set, 0);
+    } else {
+        fprintf (stderr, "Attribute format error.\n") ;
+        goto err;
+    }
+
+    if ((so == NULL) || (so->type != V_ASN1_BIT_STRING)) {
+        fprintf (stderr, "Attribute ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    altsig = X509_ATTRIBUTE_get0_data(attr, 0, V_ASN1_BIT_STRING, NULL);
+    if (altsig == NULL) {
+        fprintf (stderr, "Couldn't get ASN1 data from attribute.\n") ;
+        goto err;
+    }
+
+    return altsig;
+
+err:
+    return NULL;
+}
+
+/*
+ * Convert an X509 attribute to a Alt Signature Algorithm object.
+ */
+static X509_ALGOR *get_ALTSIGALG_from_ATTRIBUTE(X509_ATTRIBUTE *attr) {
+
+    ASN1_TYPE *so = NULL;
+    ASN1_OBJECT *o = OBJ_nid2obj(NID_alt_sigalg);
+    X509_ALGOR *altsigalg = NULL;
+    ASN1_STRING *s = NULL;
+    const unsigned char *data = NULL;
+    long length = 0;
+
+    if (OBJ_cmp(attr->object, o) != 0) {
+        fprintf (stderr, "Unexpected Object ID\n") ;
+        goto err;
+    }
+
+    if (!attr->single && sk_ASN1_TYPE_num(attr->value.set)) {
+        so = sk_ASN1_TYPE_value(attr->value.set, 0);
+    } else {
+        fprintf (stderr, "Attribute format error.\n") ;
+        goto err;
+    }
+
+    if ((so == NULL) || (so->type != V_ASN1_SEQUENCE)) {
+        fprintf (stderr, "Attribute ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    s = so->value.sequence;
+    data = ASN1_STRING_data(s);
+    length = ASN1_STRING_length(s);
+    altsigalg = d2i_X509_ALGOR(NULL, &data, length);
+    return altsigalg;
+
+err:
+    return NULL;
+}
+
+/*
+ * Fetch the alternative public key from the CSR.
+ */
+static EVP_PKEY *req_get_alt_pubkey(X509_REQ *req)
+{
+    int alt_pub_key_ind = -1;
+    X509_ATTRIBUTE *alt_pub_key_attr = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki_in = NULL;
+    X509_PUBKEY *x509_pub_alt = NULL;
+    EVP_PKEY *pkey_alt_pub = NULL;
+
+    /* Find and get the ALT public key attribute and convert it to a pkey. */
+    alt_pub_key_ind = X509_REQ_get_attr_by_NID(req, NID_subj_alt_pub_key, -1);
+    if (alt_pub_key_ind < 0) {
+        goto end;
+    }
+
+    alt_pub_key_attr = X509_REQ_get_attr(req, alt_pub_key_ind);
+    if (alt_pub_key_attr == NULL) {
+        EST_LOG_ERR("Error getting the req's ALT public key attribute.");
+        goto end;
+    }
+
+    sapki_in = get_SAPKI_from_ATTRIBUTE(alt_pub_key_attr);
+    if (sapki_in == NULL) {
+        EST_LOG_ERR("Error converting the req's ALT public key attribute into ASN.1.");
+        goto end;
+    }
+
+    x509_pub_alt = X509_PUBKEY_new();
+    if (x509_pub_alt == NULL) {
+        EST_LOG_ERR("Memory allocation error.");
+        goto end;
+    }
+
+    X509_ALGOR_free(x509_pub_alt->algor);
+    ASN1_BIT_STRING_free(x509_pub_alt->public_key);
+
+    x509_pub_alt->algor = sapki_in->algor;
+    x509_pub_alt->public_key = sapki_in->public_key;
+    x509_pub_alt->pkey = NULL;
+
+    pkey_alt_pub = X509_PUBKEY_get(x509_pub_alt);
+
+    x509_pub_alt->algor = NULL;
+    x509_pub_alt->public_key = NULL;
+    X509_PUBKEY_free(x509_pub_alt);
+    x509_pub_alt = NULL;
+
+    if (pkey_alt_pub == NULL) {
+        EST_LOG_ERR("Bad alternative public key.");
+        goto end;
+    }
+
+end:
+    if (sapki_in) {
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki_in);
+    }
+
+    return pkey_alt_pub;
+}
+
+/*
+ * Verify the alternative signature in the CSR.
+ */
+static int req_alt_verify(X509_REQ *req, EVP_PKEY *alt_pkey)
+{
+    int rv = -1;
+    int alt_sigval_ind = -1;
+    X509_ATTRIBUTE *alt_sigval_attr = NULL;
+    ASN1_BIT_STRING *req_altsig = NULL;
+    int alt_sigalg_ind = -1;
+    X509_ATTRIBUTE *alt_sigalg_attr = NULL;
+    X509_ALGOR *req_altsigalg = NULL;
+    int alg_nid = -1;
+
+    /* Find and get the ALT signature extension. */
+    alt_sigval_ind = X509_REQ_get_attr_by_NID(req, NID_alt_sigval, -1);
+    if (alt_sigval_ind < 0) {
+        EST_LOG_ERR("Error finding the req's ALT signature extension.");
+        goto end;
+    }
+
+    alt_sigval_attr = X509_REQ_get_attr(req, alt_sigval_ind);
+    if (alt_sigval_attr == NULL) {
+        EST_LOG_ERR("Error getting the req's ALT signature extension.");
+        goto end;
+    }
+
+    /* Remove the attribute to make it look the same as when it was signed. */
+    if (X509_REQ_delete_attr(req, alt_sigval_ind) == 0) {
+        EST_LOG_ERR("Error getting the req's ALT signature extension.");
+        goto end;
+    }
+
+    req_altsig = get_ALTSIGVAL_from_ATTRIBUTE(alt_sigval_attr);
+    if (req_altsig == NULL) {
+        EST_LOG_ERR("Error converting the req's ALT signature extension into ASN.1.");
+        goto end;
+    }
+
+    /* Find and get the ALT signature algorithm extension. */
+    alt_sigalg_ind = X509_REQ_get_attr_by_NID(req, NID_alt_sigalg, -1);
+    if (alt_sigalg_ind < 0) {
+        EST_LOG_ERR("Error finding the req's ALT signature algorithm extension index.");
+        goto end;
+    }
+
+    alt_sigalg_attr = X509_REQ_get_attr(req, alt_sigalg_ind);
+    if (alt_sigalg_attr == NULL) {
+        EST_LOG_ERR("Error getting the req's ALT signature algorithm extension.");
+        goto end;
+    }
+
+    req_altsigalg = get_ALTSIGALG_from_ATTRIBUTE(alt_sigalg_attr);
+    if (req_altsigalg == NULL) {
+        EST_LOG_ERR("Error converting the req's ALT signature extension into ASN.1.");
+        goto end;
+    }
+
+    /* Ensure that the signature algorithm of the sig and the alogrithm of the public key
+     * matches. We can't use X509_ALGOR_cmp() because the OIDs don't match. The
+     * signature one includes information about the digest. We don't worry about digest
+     * and parameter mismatch as the actual verification will catch that.
+     */
+    if (OBJ_find_sigid_algs(OBJ_obj2nid(req_altsigalg->algorithm), NULL, &alg_nid) == 0) {
+        EST_LOG_ERR("Couldn't get the algorithm ID from the ALT signature.");
+        goto end;
+    }
+
+    if (alg_nid != alt_pkey->type) {
+        EST_LOG_ERR("Issuer public key algorithm does not match signature algorithm");
+        EST_LOG_ERR("Issuer: %s", OBJ_nid2ln(alt_pkey->type));
+        EST_LOG_ERR("Current: %s", OBJ_nid2ln(OBJ_obj2nid(req_altsigalg->algorithm)));
+        goto end;
+    }
+
+    req->req_info->enc.modified = 1;
+
+    if (ASN1_item_verify(ASN1_ITEM_rptr(X509_REQ_INFO), req_altsigalg,
+                         req_altsig, req->req_info, alt_pkey) <= 0) {
+        EST_LOG_ERR("Alternative signature verification FAILED!");
+        rv = 0;
+        goto end;
+    }
+
+    rv = 1;
+
+end:
+    if (alt_sigval_attr) {
+        X509_ATTRIBUTE_free(alt_sigval_attr);
+    }
+    if (req_altsigalg) {
+        X509_ALGOR_free(req_altsigalg);
+    }
+
+    return rv;
+}
+
+/*
+ * Add the Subject Alternative Public Key extension to a certificate.
+ */
+static EST_ERROR cert_add_alt_pubkey(X509 *cert, EVP_PKEY *pub_alt_key)
+{
+    X509_PUBKEY *x509_pub_alt = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki_out = NULL;
+    X509_EXTENSION *ext_altspki = NULL;
+
+    EST_ERROR rv = EST_ERR_UNKNOWN;
+
+    /* Convert the pkey into an x509 format public key. */
+    X509_PUBKEY_set(&x509_pub_alt, pub_alt_key);
+    if (x509_pub_alt == NULL) {
+        EST_LOG_ERR("Couldn't create X509 alternative public key");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    sapki_out = SUBJECT_ALT_PUBLIC_KEY_INFO_new();
+    X509_ALGOR_free(sapki_out->algor);
+    ASN1_BIT_STRING_free(sapki_out->public_key);
+    sapki_out->algor = x509_pub_alt->algor;
+    sapki_out->public_key = x509_pub_alt->public_key;
+
+    /* Create and insert alt public key as an extension */
+    ext_altspki = X509V3_EXT_i2d(NID_subj_alt_pub_key, 0, sapki_out);
+    sapki_out->algor = NULL;
+    sapki_out->public_key = NULL;
+    if (ext_altspki == NULL) {
+        EST_LOG_ERR("Error converting x509 pubkey to extension");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    /* Add the alt public key extension to the cert. */
+    if (X509_add_ext(cert, ext_altspki, -1) == 0) {
+        EST_LOG_ERR("Error adding public key as extension");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    rv = EST_ERR_NONE;
+
+end:
+    if (ext_altspki) {
+        X509_EXTENSION_free(ext_altspki);
+    }
+    if (sapki_out) {
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki_out);
+    }
+    if (x509_pub_alt != NULL) {
+        X509_PUBKEY_free(x509_pub_alt);
+    }
+
+    return rv;
+}
+
+/*
+ * Add the Alt Signature Algoritm and correctly calculated Alt Signature Value
+ * extensions to the certificate.
+ */
+static EST_ERROR cert_alt_sign(X509 *cert, EVP_PKEY *pkey_alt_priv, const EVP_MD *alt_md)
+{
+    X509_PUBKEY *x509_sig_alt = NULL;
+    X509_ALGOR *algor_for_altsigalg = NULL;
+    X509_EXTENSION *ext_altsigalg = NULL;
+    EVP_MD_CTX mctx;
+    X509_ALGOR *algo_holder = NULL;
+    unsigned char *sign_in = NULL;
+    size_t sign_in_size = 0;
+    unsigned char *sign_out = NULL;
+    size_t sign_out_size = 0;
+    ASN1_BIT_STRING *alt_sigval_as_asn1bitstring = NULL;
+    int snid = -1;
+    X509_EXTENSION *ext_altsigval = NULL;
+
+    EST_ERROR rv = EST_ERR_UNKNOWN;
+
+    /* Convert the private key into an x509 public key.  This will allow us
+     * to get the algorithm identifier of the private key so we can associate
+     * it with the signature.
+     */
+    X509_PUBKEY_set(&x509_sig_alt, pkey_alt_priv);
+    if (x509_sig_alt == NULL) {
+        EST_LOG_ERR("Couldn't create X509 alternative public key");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    algor_for_altsigalg = X509_ALGOR_dup(x509_sig_alt->algor);
+    if (algor_for_altsigalg == NULL) {
+        EST_LOG_ERR("Error duplicating public key algor");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    /* Make sure that the right digest is set. */
+    if (!OBJ_find_sigid_by_algs(&snid, EVP_MD_nid(alt_md), EVP_PKEY_id(pkey_alt_priv))) {
+        EST_LOG_ERR("Error getting sigin with NID");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    /* Set the Object ID based on the NID in and then convert into an extension. */
+    if (X509_ALGOR_set0(algor_for_altsigalg, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0) == 0) {
+        EST_LOG_ERR("Error setting algorithm object ID.");
+        goto end;
+    }
+
+    ext_altsigalg = X509V3_EXT_i2d(NID_alt_sigalg, 0, algor_for_altsigalg);
+    if (ext_altsigalg == NULL) {
+        EST_LOG_ERR("Error creating signature algorithm extension.");
+        goto end;
+    }
+
+    /* Insert alt signature algorithm as an extension. */
+    if (X509_add_ext(cert, ext_altsigalg, -1) == 0) {
+        EST_LOG_ERR("Error adding signature algorithm extension.");
+        goto end;
+    }
+
+    /*
+     * Sign the tbsCert
+     */
+    EVP_MD_CTX_init(&mctx);
+
+    if (EVP_DigestSignInit(&mctx, NULL, alt_md, NULL, pkey_alt_priv) < 1) {
+        EST_LOG_ERR("Error doing EVP digest initialization");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    /* We want to hide the classical algorithm during the alternative signing process */
+    algo_holder = cert->cert_info->signature;
+    cert->cert_info->signature = NULL;
+
+    cert->cert_info->enc.modified = 1;
+
+    sign_in_size = ASN1_item_i2d((ASN1_VALUE *)cert->cert_info, &sign_in, ASN1_ITEM_rptr(X509_CINF));
+
+    sign_out_size = EVP_PKEY_size(pkey_alt_priv);
+    sign_out = OPENSSL_malloc(sign_out_size);
+    if ((sign_in == NULL) || (sign_out == NULL)) {
+        EST_LOG_ERR("Memory allocation error for signing input or output");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    if (!EVP_DigestSignUpdate(&mctx, sign_in, sign_in_size)
+        || !EVP_DigestSignFinal(&mctx, sign_out, &sign_out_size)) {
+        EST_LOG_ERR("EVP digest/sign operation error. Did you run out of HSS one-time-keys?");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    /* Done the alt signing process; bring back the signature algo specifier. */
+    cert->cert_info->signature = algo_holder;
+    algo_holder = NULL;
+
+    alt_sigval_as_asn1bitstring = ASN1_BIT_STRING_new();
+    if (alt_sigval_as_asn1bitstring == NULL) {
+        EST_LOG_ERR("ASN1 bit string memory allocation error");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    alt_sigval_as_asn1bitstring->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
+    alt_sigval_as_asn1bitstring->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+    alt_sigval_as_asn1bitstring->data = sign_out;
+    alt_sigval_as_asn1bitstring->length = sign_out_size;
+
+    sign_out = NULL;
+    sign_out_size = 0;
+
+    ext_altsigval = X509V3_EXT_i2d(NID_alt_sigval, 0, alt_sigval_as_asn1bitstring);
+    if (ext_altsigval == NULL) {
+        EST_LOG_ERR("Error creating signature extension.");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    if (X509_add_ext(cert, ext_altsigval, -1) == 0) {
+        EST_LOG_ERR("Error adding signature extension");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+    rv = EST_ERR_NONE;
+
+end:
+    if (ext_altsigval) {
+        X509_EXTENSION_free(ext_altsigval);
+    }
+    if (alt_sigval_as_asn1bitstring) {
+        ASN1_BIT_STRING_free(alt_sigval_as_asn1bitstring);
+    }
+    OPENSSL_free(sign_out);
+    OPENSSL_free(sign_in);
+    if (algo_holder) {
+        X509_ALGOR_free(algo_holder);
+    }
+    EVP_MD_CTX_cleanup(&mctx);
+    if (ext_altsigalg) {
+        X509_EXTENSION_free(ext_altsigalg);
+    }
+    if (algor_for_altsigalg) {
+        X509_ALGOR_free(algor_for_altsigalg);
+    }
+    if (x509_sig_alt != NULL) {
+        X509_PUBKEY_free(x509_sig_alt);
+    }
+
+    return rv;
+}
+
+/*
+ * This function performs a simple sanity check on a PKCS10
+ * CSR.  It will check the alt signature in the CSR.
+ * Returns 0 for success, non-zero if the sanity check failed.
+ */
+int est_server_req_check_alt_csr (X509_REQ *req)
+{
+    EVP_PKEY *pub_key = NULL;
+    int rc = 0;
+    int has_alt_spki = 0;
+    int has_alt_sigval = 0;
+    int has_alt_sigalg = 0;
+
+    has_alt_spki = (X509_REQ_get_attr_by_NID(req, NID_subj_alt_pub_key, -1) >= 0);
+    has_alt_sigval = (X509_REQ_get_attr_by_NID(req, NID_alt_sigval, -1) >= 0);
+    has_alt_sigalg = (X509_REQ_get_attr_by_NID(req, NID_alt_sigalg, -1) >= 0);
+
+    if (has_alt_spki != has_alt_sigval || has_alt_sigval != has_alt_sigalg) {
+        EST_LOG_ERR("CSR has misconfigured alt extensions");
+        return 1;
+    } else if (!has_alt_spki) {
+        EST_LOG_INFO("CSR doesn't have alt extensions, nothing to verify");
+        return 0;
+    }
+
+    /*
+     * Extract the alt public key from the CSR
+     */
+    if ((pub_key = req_get_alt_pubkey(req)) == NULL) {
+        EST_LOG_INFO("CSR doesn't have alt public key");
+        return 1;
+    }
+
+    /*
+     * Verify the alt signature in the CSR
+     */
+    rc = req_alt_verify(req, pub_key);
+    EVP_PKEY_free(pub_key);
+
+    /*
+     * Check the result
+     */
+    if (rc < 0) {
+        EST_LOG_ERR("CSR alternative signature check failed");
+        return 1;
+    } else if (rc == 0) {
+        EST_LOG_ERR("CSR alternative signature mismatch");
+        return 1;
+    } else {
+        return 0;
+    }
+}
+
+/*
+ * Add all the alternative public-key algorithm extensions to the certificate.
+ */
+EST_ERROR est_server_cert_add_alt_extensions(X509 *cert, X509_REQ *csr, EVP_PKEY *alt_priv_key, const EVP_MD *alt_md)
+{
+    EVP_PKEY *alt_pub_key = NULL;
+    EST_ERROR rv = EST_ERR_UNKNOWN;
+
+    /*
+     * If the CSR contains an alt public key, add it to the certificate
+     */
+    alt_pub_key = req_get_alt_pubkey(csr);
+    if (alt_pub_key) {
+        rv = cert_add_alt_pubkey(cert, alt_pub_key);
+        if (rv != EST_ERR_NONE) {
+            EST_LOG_ERR("Error adding alt public key to cert");
+            ossl_dump_ssl_errors();
+            goto end;
+        }
+    }
+
+    /*
+     * Sign the certificate with the alt private key and add the alt signature
+     * as an extension in the certificate.
+     */
+    rv = cert_alt_sign(cert, alt_priv_key, alt_md);
+    if (rv != EST_ERR_NONE) {
+        EST_LOG_ERR("Error adding alt signature to cert");
+        ossl_dump_ssl_errors();
+        goto end;
+    }
+
+end:
+    if (alt_pub_key != NULL) {
+        EVP_PKEY_free(alt_pub_key);
+    }
+
+    return rv;
+}
diff --git a/src/est/est_server_alt.h b/src/est/est_server_alt.h
new file mode 100644
index 0000000..0d9d670
--- /dev/null
+++ b/src/est/est_server_alt.h
@@ -0,0 +1,84 @@
+/** @file est_server_alt.h
+ *
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software plug-ins in source code or
+ * object code or both (the Software) and accompanying materials (the
+ * Documentation) that are subject to the license terms and restrictions
+ * described below (the License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (Isara) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and you refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) ZIP
+ * file, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an AS IS
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Daniel Van Geest, daniel.vangeest@isara.com, December,
+ * 2017.
+ */
+#ifndef HEADER_EST_SERVER_ALT_H
+#define HEADER_EST_SERVER_ALT_H
+
+#include <openssl/x509.h>
+
+/*
+ * These prototypes are private to est_server.c and are
+ * not part of the public API.
+ */
+int est_server_req_check_alt_csr(X509_REQ *req);
+
+#endif
diff --git a/src/est/est_server_http.c b/src/est/est_server_http.c
index 4accc22..6094612 100644
--- a/src/est/est_server_http.c
+++ b/src/est/est_server_http.c
@@ -1546,6 +1546,14 @@ static int set_ssl_option (struct mg_context *ctx)
 	EST_LOG_ERR("Unable to set server private key");
         return 0;
     }
+    /* ISARA: BEGIN */
+    if (ectx->server_alt_priv_key != NULL) {
+        if (SSL_CTX_use_ALTPrivateKey(ssl_ctx, ectx->server_alt_priv_key) == 0) {
+            EST_LOG_ERR("Unable to set server alt private key");
+            return 0;
+        }
+    }
+    /* ISARA: END */
 
     /*
      * There should be no need to include the cert chain for the
@@ -1587,6 +1595,10 @@ static void process_new_connection (struct mg_connection *conn)
     keep_alive_enabled = conn->ctx->enable_keepalives;
     keep_alive = 0;
 
+    /* ISARA: BEGIN */
+    EST_LOG_INFO("Processing connection with ciphersuite %s", SSL_get_cipher_name(conn->ssl));
+    /* ISARA: END */
+
     // Important: on new connection, reset the receiving buffer. Credit goes
     // to crule42.
     conn->data_len = 0;
diff --git a/test/UT/US1005/us1005.c b/test/UT/US1005/us1005.c
index cf97737..686e8cd 100644
--- a/test/UT/US1005/us1005.c
+++ b/test/UT/US1005/us1005.c
@@ -241,7 +241,7 @@ static void us1005_easy_provision (char *cn, char *server, int ba_hint,
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, cert, key);
+    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, cert, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     if (ba_hint) {
@@ -264,7 +264,7 @@ static void us1005_easy_provision (char *cn, char *server, int ba_hint,
      * Attempt to provision a new cert
      */
     rv = est_client_provision_cert(ectx, cn, &pkcs7_len, &ca_certs_len,
-        new_key);
+        new_key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
     EVP_PKEY_free(new_key);
 
@@ -394,7 +394,7 @@ static void us1005_test5 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -411,25 +411,25 @@ static void us1005_test5 (void)
     /*
      * Try with a NULL context
      */
-    rv = est_client_provision_cert(NULL, "TEST2", &p7len, &calen, key);
+    rv = est_client_provision_cert(NULL, "TEST2", &p7len, &calen, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NO_CTX);
 
     /*
      * Try with a NULL p7 length
      */
-    rv = est_client_provision_cert(ectx, "TEST2", NULL, &calen, key);
+    rv = est_client_provision_cert(ectx, "TEST2", NULL, &calen, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_INVALID_PARAMETERS);
 
     /*
      * Try with a NULL cacerts length
      */
-    rv = est_client_provision_cert(ectx, "TEST2", &p7len, NULL, key);
+    rv = est_client_provision_cert(ectx, "TEST2", &p7len, NULL, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_INVALID_PARAMETERS);
 
     /*
      * Try with a NULL key
      */
-    rv = est_client_provision_cert(ectx, "TEST2", &p7len, &calen, NULL);
+    rv = est_client_provision_cert(ectx, "TEST2", &p7len, &calen, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NO_KEY);
 
     EVP_PKEY_free(key);
diff --git a/test/UT/US1060/us1060c.c b/test/UT/US1060/us1060c.c
index 7ce4ad3..36ed3b4 100644
--- a/test/UT/US1060/us1060c.c
+++ b/test/UT/US1060/us1060c.c
@@ -272,7 +272,7 @@ static void us1060c_easy_provision (int use_srp, int use_ta, char *cipher_suite,
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US1060C_UID, US1060C_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US1060C_UID, US1060C_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -305,7 +305,7 @@ static void us1060c_easy_provision (int use_srp, int use_ta, char *cipher_suite,
     /*
      * Attempt to provision a new cert
      */
-    rv = est_client_provision_cert(ectx, "US1060C_TEST1xx", &pkcs7_len, &ca_certs_len, new_key);
+    rv = est_client_provision_cert(ectx, "US1060C_TEST1xx", &pkcs7_len, &ca_certs_len, new_key, NULL /*ISARA*/);
     CU_ASSERT(rv == expected_rv);
     if (rv != expected_rv) {
 	printf("\nExpected rv was %d, rv returned was %d", expected_rv, rv);
@@ -431,7 +431,7 @@ static void us1060c_test103 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US1060C_UID, US1060C_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US1060C_UID, US1060C_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -463,7 +463,7 @@ static void us1060c_test103 (void)
     /*
      * Attempt to provision a new cert
      */
-    rv = est_client_enroll(ectx, "US1060C_TEST103", &pkcs7_len, new_key);
+    rv = est_client_enroll(ectx, "US1060C_TEST103", &pkcs7_len, new_key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_FQDN_MISMATCH);
 
     /*
@@ -505,7 +505,7 @@ static void us1060c_test104 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US1060C_UID, US1060C_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US1060C_UID, US1060C_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -527,7 +527,7 @@ static void us1060c_test104 (void)
     /*
      * Attempt to provision a new cert
      */
-    rv = est_client_enroll(ectx, "US1060C_TEST104", &pkcs7_len, new_key);
+    rv = est_client_enroll(ectx, "US1060C_TEST104", &pkcs7_len, new_key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -572,7 +572,7 @@ static void us1060c_test105 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US1060C_UID, US1060C_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US1060C_UID, US1060C_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -604,7 +604,7 @@ static void us1060c_test105 (void)
     /*
      * Attempt to provision a new cert
      */
-    rv = est_client_enroll(ectx, "US1060C_TEST105", &pkcs7_len, new_key);
+    rv = est_client_enroll(ectx, "US1060C_TEST105", &pkcs7_len, new_key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_SSL_CONNECT);
 
     /*
@@ -644,7 +644,7 @@ static void us1060c_test106 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US1060C_UID, US1060C_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US1060C_UID, US1060C_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -675,7 +675,7 @@ static void us1060c_test106 (void)
     /*
      * Attempt to provision a new cert
      */
-    rv = est_client_enroll(ectx, "US1060C_TEST106a", &pkcs7_len, new_key);
+    rv = est_client_enroll(ectx, "US1060C_TEST106a", &pkcs7_len, new_key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_SSL_CONNECT);
 
     /*
@@ -688,7 +688,7 @@ static void us1060c_test106 (void)
     /*
      * Attempt to provision a new cert
      */
-    rv = est_client_enroll(ectx, "US1060C_TEST106b", &pkcs7_len, new_key);
+    rv = est_client_enroll(ectx, "US1060C_TEST106b", &pkcs7_len, new_key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
diff --git a/test/UT/US1159/us1159.c b/test/UT/US1159/us1159.c
index c1c751c..8483d88 100644
--- a/test/UT/US1159/us1159.c
+++ b/test/UT/US1159/us1159.c
@@ -270,7 +270,7 @@ static void us1159_test1 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
+    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -287,7 +287,7 @@ static void us1159_test1 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ctx, "Test 1", &pkcs7_len, key);
+    rv = est_client_enroll(ctx, "Test 1", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -521,7 +521,7 @@ static void us1159_test2 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
+    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -532,7 +532,7 @@ static void us1159_test2 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
+    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -605,7 +605,7 @@ static void us1159_test3 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
+    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -616,7 +616,7 @@ static void us1159_test3 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
+    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);
 
     /*
@@ -683,7 +683,7 @@ static void us1159_test4 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
+    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -694,7 +694,7 @@ static void us1159_test4 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
+    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);
 
     /*
@@ -753,7 +753,7 @@ static void us1159_test10 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
+    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     rv = est_client_force_pop(ctx);
@@ -767,7 +767,7 @@ static void us1159_test10 (void)
     /*
      * Enroll a new cert
      */
-    rv = est_client_enroll(ctx, "Test 10", &pkcs7_len, key);
+    rv = est_client_enroll(ctx, "Test 10", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -844,7 +844,7 @@ static void us1159_test20 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
+    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -855,7 +855,7 @@ static void us1159_test20 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
+    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -951,7 +951,7 @@ static void us1159_test21 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
+    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -962,7 +962,7 @@ static void us1159_test21 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
+    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1029,7 +1029,7 @@ static void us1159_test50 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
+    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1040,7 +1040,7 @@ static void us1159_test50 (void)
     /*
      * Enroll a new cert
      */
-    rv = est_client_enroll(ctx, "Test 50", &pkcs7_len, key);
+    rv = est_client_enroll(ctx, "Test 50", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1090,7 +1090,7 @@ static void us1159_test51 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
+    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1101,7 +1101,7 @@ static void us1159_test51 (void)
     /*
      * Enroll a new cert
      */
-    rv = est_client_enroll(ctx, "Test 51", &pkcs7_len, key);
+    rv = est_client_enroll(ctx, "Test 51", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
diff --git a/test/UT/US1864/us1864.c b/test/UT/US1864/us1864.c
index 4048508..9012528 100644
--- a/test/UT/US1864/us1864.c
+++ b/test/UT/US1864/us1864.c
@@ -200,7 +200,7 @@ static void us1864_test1 (void)
      */
     est_init_logger(EST_LOG_LVL_INFO, NULL);
     ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
-        EST_CERT_FORMAT_PEM, "testrealm", x, priv_key);
+        EST_CERT_FORMAT_PEM, "testrealm", x, priv_key, NULL /*ISARA*/);
 
     CU_ASSERT(ctx != NULL);
 
diff --git a/test/UT/US1883/us1883.c b/test/UT/US1883/us1883.c
index d8545ed..1fb9e0e 100644
--- a/test/UT/US1883/us1883.c
+++ b/test/UT/US1883/us1883.c
@@ -422,7 +422,7 @@ static void us1883_simple_enroll (char *cn, char *server, EST_ERROR expected_enr
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
+    rv = est_client_enroll(ectx, cn, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == expected_enroll_rv);
 
     /*
@@ -491,7 +491,7 @@ void us1883_simple_reenroll (char *cn, char *server, EST_ERROR expected_enroll_r
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
+    rv = est_client_enroll(ectx, cn, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -565,7 +565,7 @@ void us1883_simple_reenroll (char *cn, char *server, EST_ERROR expected_enroll_r
      * Once 1884 is complete, the below ASSERT will begin to fail and will need
      * to be changed to a passing response.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == expected_enroll_rv);
     
     /*
diff --git a/test/UT/US2174/us2174.c b/test/UT/US2174/us2174.c
index 7c52a5a..ab10a90 100644
--- a/test/UT/US2174/us2174.c
+++ b/test/UT/US2174/us2174.c
@@ -351,7 +351,7 @@ static void us2174_simple_enroll (char *cn, char *server,
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
+    rv = est_client_enroll(ectx, cn, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == expected_enroll_rv);
 
     /*
@@ -406,7 +406,7 @@ void us2174_simple_reenroll (char *cn, char *server,
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
+    rv = est_client_enroll(ectx, cn, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -480,7 +480,7 @@ void us2174_simple_reenroll (char *cn, char *server,
      * Once 1884 is complete, the below ASSERT will begin to fail and will need
      * to be changed to a passing response.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == expected_enroll_rv);
 
     /*
diff --git a/test/UT/US3496/us3496.c b/test/UT/US3496/us3496.c
index 6c0a770..669293c 100644
--- a/test/UT/US3496/us3496.c
+++ b/test/UT/US3496/us3496.c
@@ -247,7 +247,7 @@ static void us3496_test1 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, NULL);    
@@ -296,7 +296,7 @@ static void us3496_test2 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
@@ -346,7 +346,7 @@ static void us3496_test3 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
@@ -398,7 +398,7 @@ static void us3496_test4 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
@@ -448,7 +448,7 @@ static void us3496_test5 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
@@ -499,7 +499,7 @@ static void us3496_test6 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
@@ -549,7 +549,7 @@ static void us3496_test7 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
@@ -600,7 +600,7 @@ static void us3496_test8 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
@@ -651,7 +651,7 @@ static void us3496_test9 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
@@ -702,7 +702,7 @@ static void us3496_test10 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, "-._~:@!$&'()*+,;=");    
@@ -752,7 +752,7 @@ static void us3496_test11 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
diff --git a/test/UT/US3512/us3512.c b/test/UT/US3512/us3512.c
index d764b3a..c7ced00 100644
--- a/test/UT/US3512/us3512.c
+++ b/test/UT/US3512/us3512.c
@@ -346,7 +346,7 @@ static void us3512_simple_enroll (char *cn, char *server,
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -369,7 +369,7 @@ static void us3512_simple_enroll (char *cn, char *server,
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
+    rv = est_client_enroll(ectx, cn, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == expected_enroll_rv);
 
     /*
@@ -466,7 +466,7 @@ static void us3512_test3 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -490,7 +490,7 @@ static void us3512_test3 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, "TC-US898-1", &pkcs7_len, key);
+    rv = est_client_enroll(ectx, "TC-US898-1", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
     if (rv != EST_ERR_NONE)
         return;
@@ -544,7 +544,7 @@ static void us3512_test3 (void)
     memset(tst_srvr_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);
     memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);
 
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_auth) == 0);
@@ -606,7 +606,7 @@ static void us3512_test4 (void)
         client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,
@@ -701,7 +701,7 @@ static void us3512_test5 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -945,7 +945,7 @@ static void us3512_test12 (void)
         client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ectx, US3512_SERVER_IP, US3512_TCP_PROXY_PORT,
diff --git a/test/UT/US3612/us3612.c b/test/UT/US3612/us3612.c
index 680b116..7f4ba86 100644
--- a/test/UT/US3612/us3612.c
+++ b/test/UT/US3612/us3612.c
@@ -305,7 +305,7 @@ static void us3612_test1 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -335,7 +335,7 @@ static void us3612_test1 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, "TCUS3612-1", &pkcs7_len, key);
+    rv = est_client_enroll(ectx, "TCUS3612-1", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -384,7 +384,7 @@ static void us3612_test2 (void)
      /*
       * Set the authentication mode to use a user id/password
       */
-     rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);
+     rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL, NULL /*ISARA*/);
      CU_ASSERT(rv == EST_ERR_NONE);
 
      /*
@@ -414,7 +414,7 @@ static void us3612_test2 (void)
      /*
       * Use the simplified API to enroll a CSR
       */
-     rv = est_client_enroll(ectx, "TC3612-2", &pkcs7_len, key);
+     rv = est_client_enroll(ectx, "TC3612-2", &pkcs7_len, key, NULL /*ISARA*/);
      CU_ASSERT(rv != EST_ERR_NONE);
 
      /*
@@ -453,7 +453,7 @@ static void us3612_test3 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -489,7 +489,7 @@ static void us3612_test3 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, "TCUS3612-3", &pkcs7_len, key);
+    rv = est_client_enroll(ectx, "TCUS3612-3", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
diff --git a/test/UT/US4020/us4020.c b/test/UT/US4020/us4020.c
index aa220aa..097fa54 100644
--- a/test/UT/US4020/us4020.c
+++ b/test/UT/US4020/us4020.c
@@ -516,7 +516,7 @@ static void us4020_test2 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
+    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     /*
@@ -533,7 +533,7 @@ static void us4020_test2 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    e_rc = est_client_enroll(ectx, "TC4020-2", &pkcs7_len, key);
+    e_rc = est_client_enroll(ectx, "TC4020-2", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     shutdown_antinat();    
@@ -585,7 +585,7 @@ static void us4020_test3 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
+    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     /*
@@ -602,7 +602,7 @@ static void us4020_test3 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    e_rc = est_client_enroll(ectx, "TC4020-3", &pkcs7_len, key);
+    e_rc = est_client_enroll(ectx, "TC4020-3", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     shutdown_antinat();    
@@ -655,7 +655,7 @@ static void us4020_test4 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
+    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     /*
@@ -672,7 +672,7 @@ static void us4020_test4 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    e_rc = est_client_enroll(ectx, "TC4020-4", &pkcs7_len, key);
+    e_rc = est_client_enroll(ectx, "TC4020-4", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     shutdown_antinat();    
@@ -725,7 +725,7 @@ static void us4020_test5 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
+    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     /*
@@ -742,7 +742,7 @@ static void us4020_test5 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    e_rc = est_client_enroll(ectx, "TC4020-5", &pkcs7_len, key);
+    e_rc = est_client_enroll(ectx, "TC4020-5", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     shutdown_antinat();    
@@ -794,7 +794,7 @@ static void us4020_test6 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
+    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     /*
@@ -811,7 +811,7 @@ static void us4020_test6 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
+    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
     
     shutdown_antinat();
@@ -863,7 +863,7 @@ static void us4020_test7 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
+    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     /*
@@ -880,7 +880,7 @@ static void us4020_test7 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
+    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
     
     shutdown_antinat();
@@ -932,7 +932,7 @@ static void us4020_test8 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
+    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     /*
@@ -949,7 +949,7 @@ static void us4020_test8 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
+    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_IP_CONNECT);
     
     shutdown_antinat();
@@ -1001,7 +1001,7 @@ static void us4020_test9 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
+    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     /*
@@ -1018,7 +1018,7 @@ static void us4020_test9 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
+    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_IP_CONNECT);
     
     shutdown_antinat();
@@ -1074,7 +1074,7 @@ static void us4020_test8 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
+    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     /*
@@ -1091,7 +1091,7 @@ static void us4020_test8 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    e_rc = est_client_enroll(ectx, "TC4020-7", &pkcs7_len, key);
+    e_rc = est_client_enroll(ectx, "TC4020-7", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     shutdown_antinat();    
@@ -1143,7 +1143,7 @@ static void us4020_test10 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
+    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     /*
@@ -1160,7 +1160,7 @@ static void us4020_test10 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    e_rc = est_client_enroll(ectx, "TC4020-8", &pkcs7_len, key);
+    e_rc = est_client_enroll(ectx, "TC4020-8", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(e_rc == EST_ERR_NONE);
 
     shutdown_haproxy();    
diff --git a/test/UT/US748/us748.c b/test/UT/US748/us748.c
index cd7ce76..4b0f07b 100644
--- a/test/UT/US748/us748.c
+++ b/test/UT/US748/us748.c
@@ -493,7 +493,7 @@ static void us748_test7 (void)
      * Specify user ID and password since the server is running
      * in Basic Authentication mode.
      */
-    rv = est_client_set_auth(c_ctx, "estuser", "estpwd", NULL, NULL);
+    rv = est_client_set_auth(c_ctx, "estuser", "estpwd", NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
     est_client_set_server(c_ctx, "127.0.0.1", US748_TCP_PROXY_PORT, NULL);
 
@@ -508,7 +508,7 @@ static void us748_test7 (void)
     /*
      * Attempt to enroll a CSR
      */
-    rv = est_client_enroll(c_ctx, "US748-test7 CN", &pkcs7_len, new_pkey);
+    rv = est_client_enroll(c_ctx, "US748-test7 CN", &pkcs7_len, new_pkey, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -586,7 +586,7 @@ static void us748_test9 (void)
     /*
      * We'll use simple HTTP auth to identify ourselves
      */
-    rv = est_client_set_auth(ctx, "estuser", "estpwd", NULL, NULL);
+    rv = est_client_set_auth(ctx, "estuser", "estpwd", NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     est_client_set_server(ctx, "127.0.0.1", US748_TCP_PROXY_PORT, NULL);
@@ -605,7 +605,7 @@ static void us748_test9 (void)
      */
     ctx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this 
     //We need to force the challengePassword into the CSR    
-    rv = est_client_enroll(ctx, "TestCase9", &pkcs7_len, new_pkey);
+    rv = est_client_enroll(ctx, "TestCase9", &pkcs7_len, new_pkey, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     pkcs7 = malloc(pkcs7_len);
diff --git a/test/UT/US893/us893.c b/test/UT/US893/us893.c
index c9212cc..8e60bea 100644
--- a/test/UT/US893/us893.c
+++ b/test/UT/US893/us893.c
@@ -251,7 +251,7 @@ static void us893_test2 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -293,7 +293,7 @@ static void us893_test2 (void)
     /*
      * Enroll an expired cert that contains x509 extensions.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -447,7 +447,7 @@ static void us893_test4 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -489,7 +489,7 @@ static void us893_test4 (void)
     /*
      * Enroll an expired cert that contains x509 extensions.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);
 
     /*
@@ -749,7 +749,7 @@ static void us893_test7 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -793,7 +793,7 @@ static void us893_test7 (void)
      */
     ectx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this 
     //We need to force the challengePassword into the CSR
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);
 
     /*
@@ -863,7 +863,7 @@ static void us893_test8 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -905,7 +905,7 @@ static void us893_test8 (void)
     /*
      * Enroll an expired cert that contains x509 extensions.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     est_destroy(ectx);
diff --git a/test/UT/US895/us895.c b/test/UT/US895/us895.c
index 22b4a96..d65d539 100644
--- a/test/UT/US895/us895.c
+++ b/test/UT/US895/us895.c
@@ -336,7 +336,7 @@ static void us895_test1 (void)
         proxy_manual_cert_verify);
     CU_ASSERT(ctx != NULL);
 
-    rc = est_client_set_auth(ctx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ctx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ctx, US895_SERVER_IP, US895_PROXY_PORT, NULL);
diff --git a/test/UT/US896/us896.c b/test/UT/US896/us896.c
index af9115d..3a7f830 100644
--- a/test/UT/US896/us896.c
+++ b/test/UT/US896/us896.c
@@ -201,7 +201,7 @@ static void us896_test2(void) {
             client_manual_cert_verify);
     CU_ASSERT(ctx != NULL);
 
-    rc = est_client_set_auth(ctx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ctx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ctx, US896_SERVER_IP, US896_SERVER_PORT, NULL);
diff --git a/test/UT/US897/us897.c b/test/UT/US897/us897.c
index cfbf72b..76399bb 100644
--- a/test/UT/US897/us897.c
+++ b/test/UT/US897/us897.c
@@ -196,7 +196,7 @@ static void us897_test1 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
                              
     CU_ASSERT(rc == EST_ERR_NONE);
     
@@ -292,7 +292,7 @@ static void us897_test3 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     if (ectx) {
@@ -340,7 +340,7 @@ static void us897_test3 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     if (ectx) {
@@ -391,7 +391,7 @@ static void us897_test6 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "USER", "PASSWORD", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "USER", "PASSWORD", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     if (ectx) {
@@ -441,7 +441,7 @@ static void us897_test7 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "USER", NULL, NULL, priv_key);
+    rc = est_client_set_auth(ectx, "USER", NULL, NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);
 
     if (ectx) {
@@ -452,7 +452,7 @@ static void us897_test7 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, NULL, "PASSWORD", NULL, priv_key);
+    rc = est_client_set_auth(ectx, NULL, "PASSWORD", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);
     
     if (ectx) {
@@ -498,7 +498,7 @@ static void us897_test9 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     rc = est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);    
@@ -552,7 +552,7 @@ static void us897_test10 (void)
     ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     /*
@@ -628,7 +628,7 @@ static void us897_test11 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);    
 
     est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
@@ -711,7 +711,7 @@ static void us897_test12 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
@@ -796,7 +796,7 @@ static void us897_test13 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
@@ -897,7 +897,7 @@ static void us897_test14 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
@@ -999,7 +999,7 @@ static void us897_test15 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
@@ -1110,7 +1110,7 @@ static void us897_test16 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
@@ -1221,7 +1221,7 @@ static void us897_test17 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
@@ -1308,7 +1308,7 @@ static void us897_test18 (void)
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);
 
-    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ectx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
diff --git a/test/UT/US898/us898.c b/test/UT/US898/us898.c
index f007661..0ef2f82 100644
--- a/test/UT/US898/us898.c
+++ b/test/UT/US898/us898.c
@@ -280,7 +280,7 @@ static void us898_test1 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -303,7 +303,7 @@ static void us898_test1 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, "TC-US898-1", &pkcs7_len, key);
+    rv = est_client_enroll(ectx, "TC-US898-1", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
     if (rv != EST_ERR_NONE) return;
 
@@ -353,7 +353,7 @@ static void us898_test1 (void)
      * Now that we have an X509 representation of the cert,
      * let's try to re-enroll this cert with the CA
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -406,7 +406,7 @@ static void us898_test2 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -446,7 +446,7 @@ static void us898_test2 (void)
     /*
      * Enroll an expired cert that contains x509 extensions.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -549,7 +549,7 @@ static void us898_test3 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -572,7 +572,7 @@ static void us898_test3 (void)
     /*
      * re-enroll using a null x509 pointer.
      */
-    rv = est_client_reenroll(ectx, NULL, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, NULL, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NO_CERT);
 
     /*
@@ -611,7 +611,7 @@ static void us898_test4 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -642,7 +642,7 @@ static void us898_test4 (void)
     /*
      * re-enroll using a null EVP_KEY pointer.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, NULL);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NO_KEY);
 
     /*
@@ -684,7 +684,7 @@ static void us898_test5 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -724,7 +724,7 @@ static void us898_test5 (void)
     /*
      * Enroll an expired cert that contains x509 extensions.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_CLIENT_INVALID_KEY);
 
     /*
@@ -778,7 +778,7 @@ static void us898_test6 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -818,7 +818,7 @@ static void us898_test6 (void)
     /*
      * Enroll an expired cert that contains x509 extensions.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);
 
     /*
@@ -870,7 +870,7 @@ static void us898_test7 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, "hoagie", "chili", NULL, NULL);
+    rv = est_client_set_auth(ectx, "hoagie", "chili", NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -910,7 +910,7 @@ static void us898_test7 (void)
     /*
      * Enroll an expired cert that contains x509 extensions.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_AUTH_FAIL);
 
     est_destroy(ectx);
@@ -953,7 +953,7 @@ static void us898_test8 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -993,7 +993,7 @@ static void us898_test8 (void)
     /*
      * Enroll an expired cert that contains x509 extensions.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     est_destroy(ectx);
@@ -1043,7 +1043,7 @@ static void us898_test9 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, "jdoe", "panthers", NULL, NULL);
+    rv = est_client_set_auth(ectx, "jdoe", "panthers", NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1083,7 +1083,7 @@ static void us898_test9 (void)
     /*
      * Enroll an expired cert that contains x509 extensions.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_AUTH_FAIL);
 
     /*
@@ -1177,7 +1177,7 @@ static void us898_test10 (void)
      * Set the authentication mode to use the certificate 
      * No HTTP auth credentials are provided.
      */
-    rv = est_client_set_auth(ectx, NULL, NULL, cert, key);
+    rv = est_client_set_auth(ectx, NULL, NULL, cert, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1195,7 +1195,7 @@ static void us898_test10 (void)
      * Enroll a cert, should fail because we 
      * didn't provide valid HTTP auth credentials
      */
-    rv = est_client_enroll(ectx, "TC-US898-10", &pkcs7_len, key);
+    rv = est_client_enroll(ectx, "TC-US898-10", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_AUTH_FAIL);
 
     /*
@@ -1204,7 +1204,7 @@ static void us898_test10 (void)
      * and HTTP auth isn't required for re-enroll even when
      * the server has enabled HTTP auth.
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     est_destroy(ectx);
@@ -1268,7 +1268,7 @@ static void us898_test11 (void)
      * Set the authentication mode to use the expired certificate 
      * and valid HTTP auth credentials.
      */
-    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, cert, key);
+    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, cert, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1285,7 +1285,7 @@ static void us898_test11 (void)
     /*
      * Re-Enroll the cert 
      */
-    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
+    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_SSL_CONNECT);
 
     est_destroy(ectx);
diff --git a/test/UT/US899/us899.c b/test/UT/US899/us899.c
index 7f68fda..c0b0ee6 100644
--- a/test/UT/US899/us899.c
+++ b/test/UT/US899/us899.c
@@ -372,7 +372,7 @@ static void us899_simple_enroll (char *cn, char *server, EST_ERROR expected_enro
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -395,7 +395,7 @@ static void us899_simple_enroll (char *cn, char *server, EST_ERROR expected_enro
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
+    rv = est_client_enroll(ectx, cn, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == expected_enroll_rv);
 
     /*
@@ -466,7 +466,7 @@ static void us899_test2 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -496,7 +496,7 @@ static void us899_test2 (void)
     /*
      * Use the alternate API to enroll an existing CSR
      */
-    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, key);
+    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -551,7 +551,7 @@ static void us899_test3 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -568,7 +568,7 @@ static void us899_test3 (void)
     /*
      * Use the alternate API to enroll a null CSR
      */
-    rv = est_client_enroll_csr(ectx, NULL, &pkcs7_len, key);
+    rv = est_client_enroll_csr(ectx, NULL, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NO_CSR);
 
     /*
@@ -660,7 +660,7 @@ static void us899_test5 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -697,7 +697,7 @@ static void us899_test5 (void)
     /*
      * Use the alternate API to enroll an existing CSR.  This should pass.
      */
-    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, key);
+    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1171,7 +1171,7 @@ static void us899_test16 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1194,7 +1194,7 @@ static void us899_test16 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, "TEST16-CN", &pkcs7_len, key);
+    rv = est_client_enroll(ectx, "TEST16-CN", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1294,7 +1294,7 @@ static void us899_test17 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1317,7 +1317,7 @@ static void us899_test17 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, "TEST17-CN", &pkcs7_len, key);
+    rv = est_client_enroll(ectx, "TEST17-CN", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_SSL_CONNECT);
 
     /*
@@ -1371,7 +1371,7 @@ static void us899_test18 (void)
     /*
      * Set the authentication mode to use a user id/password
      */
-    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
+    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -1394,7 +1394,7 @@ static void us899_test18 (void)
     /*
      * Use the simplified API to enroll a CSR
      */
-    rv = est_client_enroll(ectx, "TEST18-CN", &pkcs7_len, key);
+    rv = est_client_enroll(ectx, "TEST18-CN", &pkcs7_len, key, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);
 
     if (rv == EST_ERR_CA_ENROLL_RETRY) {
diff --git a/test/UT/US900/us900.c b/test/UT/US900/us900.c
index 33c4cdc..92c3ace 100644
--- a/test/UT/US900/us900.c
+++ b/test/UT/US900/us900.c
@@ -409,7 +409,7 @@ static void us900_test2 (void)
         client_manual_cert_verify);
     CU_ASSERT(ctx != NULL);
 
-    rc = est_client_set_auth(ctx, "", "", NULL, priv_key);
+    rc = est_client_set_auth(ctx, "", "", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(rc == EST_ERR_NONE);
 
     est_client_set_server(ctx, US900_SERVER_IP, US900_SERVER_PORT, NULL);
diff --git a/test/UT/US901/us901.c b/test/UT/US901/us901.c
index 3243aac..daf5323 100644
--- a/test/UT/US901/us901.c
+++ b/test/UT/US901/us901.c
@@ -660,7 +660,7 @@ static void us901_test15(void) {
     est_init_logger(EST_LOG_LVL_INFO, NULL);
     ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
             EST_CERT_FORMAT_PEM,
-            NULL, x, priv_key);
+            NULL, x, priv_key, NULL /*ISARA*/);
     CU_ASSERT(ctx == NULL);
 
     X509_free(x);
@@ -702,7 +702,7 @@ static void us901_test16(void) {
      */
     est_init_logger(EST_LOG_LVL_INFO, NULL);
     ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
-            EST_CERT_FORMAT_PEM, "testrealm", NULL, priv_key);
+            EST_CERT_FORMAT_PEM, "testrealm", NULL, priv_key, NULL /*ISARA*/);
     CU_ASSERT(ctx == NULL);
 
     EVP_PKEY_free(priv_key);
@@ -743,7 +743,7 @@ static void us901_test17(void) {
      */
     est_init_logger(EST_LOG_LVL_INFO, NULL);
     ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
-            EST_CERT_FORMAT_PEM, "testrealm", x, NULL);
+            EST_CERT_FORMAT_PEM, "testrealm", x, NULL, NULL /*ISARA*/);
     CU_ASSERT(ctx == NULL);
 
     X509_free(x);
@@ -787,7 +787,7 @@ static void us901_test18(void) {
      */
     est_init_logger(EST_LOG_LVL_INFO, NULL);
     ctx = est_server_init(NULL, 0, NULL, 0, EST_CERT_FORMAT_PEM, "testrealm", x,
-            priv_key);
+            priv_key, NULL /*ISARA*/);
     CU_ASSERT(ctx == NULL);
 
     X509_free(x);
@@ -833,7 +833,7 @@ static void us901_test19(void) {
     est_init_logger(EST_LOG_LVL_INFO, NULL);
     ctx = est_server_init((unsigned char*) "Bogus CA chain", 14,
             (unsigned char*) "Bogus CA chain", 14, EST_CERT_FORMAT_PEM,
-            "testrealm", x, priv_key);
+            "testrealm", x, priv_key, NULL /*ISARA*/);
     CU_ASSERT(ctx == NULL);
 
     X509_free(x);
diff --git a/test/UT/US903/us903.c b/test/UT/US903/us903.c
index 0aedcd0..11346f6 100644
--- a/test/UT/US903/us903.c
+++ b/test/UT/US903/us903.c
@@ -452,7 +452,7 @@ static void us903_test7 (void)
      * Specify user ID and password since the server is running
      * in Basic Authentication mode.
      */
-    rv = est_client_set_auth(c_ctx, "estuser", "estpwd", NULL, NULL);
+    rv = est_client_set_auth(c_ctx, "estuser", "estpwd", NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
     est_client_set_server(c_ctx, "127.0.0.1", US903_TCP_PORT, NULL);
 
@@ -467,7 +467,7 @@ static void us903_test7 (void)
     /*
      * Attempt to enroll a CSR
      */
-    rv = est_client_enroll(c_ctx, "US903-test7 CN", &pkcs7_len, new_pkey);
+    rv = est_client_enroll(c_ctx, "US903-test7 CN", &pkcs7_len, new_pkey, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     /*
@@ -590,7 +590,7 @@ static void us903_test9 (void)
     /*
      * We'll use simple HTTP auth to identify ourselves
      */
-    rv = est_client_set_auth(ctx, "estuser", "estpwd", NULL, NULL);
+    rv = est_client_set_auth(ctx, "estuser", "estpwd", NULL, NULL, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     est_client_set_server(ctx, "127.0.0.1", US903_TCP_PORT, NULL);
@@ -609,7 +609,7 @@ static void us903_test9 (void)
      */
     ctx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this 
     //We need to force the challengePassword into the CSR    
-    rv = est_client_enroll(ctx, "TestCase9", &pkcs7_len, new_pkey);
+    rv = est_client_enroll(ctx, "TestCase9", &pkcs7_len, new_pkey, NULL /*ISARA*/);
     CU_ASSERT(rv == EST_ERR_NONE);
 
     pkcs7 = malloc(pkcs7_len);
diff --git a/test/util/st_server.c b/test/util/st_server.c
index 2c11cac..1de2f4e 100644
--- a/test/util/st_server.c
+++ b/test/util/st_server.c
@@ -33,7 +33,13 @@
 #include <sys/select.h>
 #include <netinet/in.h>
 
+/* ISARA: BEGIN */
+/*
 #define MAX_CERT_LEN 8192
+*/
+/* Dual-key certificates are large, so increase maximum size */
+#define MAX_CERT_LEN 262144
+/* ISARA: END */
 #define MAX_FILENAME_LEN 255
 
 BIO *bio_err = NULL;
@@ -942,11 +948,11 @@ static int st_start_internal (
     if (disable_cacerts_response) {
         ectx = est_server_init(trustcerts, trustcerts_len, 
                                NULL, 0, 
-                               EST_CERT_FORMAT_PEM, realm, x, priv_key);
+                               EST_CERT_FORMAT_PEM, realm, x, priv_key, NULL /*ISARA*/);
     } else {
         ectx = est_server_init(trustcerts, trustcerts_len, 
                                cacerts_raw, cacerts_len, 
-                               EST_CERT_FORMAT_PEM, realm, x, priv_key);
+                               EST_CERT_FORMAT_PEM, realm, x, priv_key, NULL /*ISARA*/);
     }
     
     if (!ectx) {
diff --git a/test/util/st_server_windows.c b/test/util/st_server_windows.c
index 1ef0490..8e4657e 100644
--- a/test/util/st_server_windows.c
+++ b/test/util/st_server_windows.c
@@ -1107,7 +1107,7 @@ static int st_start_internal(
 
     ectx = est_server_init(trustcerts, trustcerts_len,
         cacerts_raw, cacerts_len,
-        EST_CERT_FORMAT_PEM, realm, x, priv_key);
+        EST_CERT_FORMAT_PEM, realm, x, priv_key, NULL /*ISARA*/);
     if (!ectx) {
         printf("\nUnable to initialize EST context.  Aborting!!!\n");
         return (-1);
